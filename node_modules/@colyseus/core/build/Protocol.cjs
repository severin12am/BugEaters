"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/core/src/Protocol.ts
var Protocol_exports = {};
__export(Protocol_exports, {
  IpcProtocol: () => IpcProtocol,
  getMessageBytes: () => getMessageBytes
});
module.exports = __toCommonJS(Protocol_exports);
var import_msgpackr = require("@colyseus/msgpackr");
var import_schema = require("@colyseus/schema");
var import_shared_types = require("@colyseus/shared-types");
var IpcProtocol = {
  SUCCESS: 0,
  ERROR: 1,
  TIMEOUT: 2
};
var packr = new import_msgpackr.Packr({
  useRecords: false
  // increased compatibility with decoders other than "msgpackr"
});
packr.encode(void 0);
var getMessageBytes = {
  [import_shared_types.Protocol.JOIN_ROOM]: (reconnectionToken, serializerId, handshake) => {
    const it = { offset: 1 };
    packr.buffer[0] = import_shared_types.Protocol.JOIN_ROOM;
    packr.buffer[it.offset++] = Buffer.byteLength(reconnectionToken, "utf8");
    import_schema.encode.utf8Write(packr.buffer, reconnectionToken, it);
    packr.buffer[it.offset++] = Buffer.byteLength(serializerId, "utf8");
    import_schema.encode.utf8Write(packr.buffer, serializerId, it);
    let handshakeLength = handshake?.byteLength || 0;
    if (handshakeLength > packr.buffer.byteLength - it.offset) {
      packr.useBuffer(Buffer.alloc(it.offset + handshakeLength, packr.buffer));
    }
    if (handshakeLength > 0) {
      packr.buffer.set(handshake, it.offset);
    }
    return Buffer.from(packr.buffer.subarray(0, it.offset + handshakeLength));
  },
  [import_shared_types.Protocol.ERROR]: (code, message = "") => {
    const it = { offset: 1 };
    packr.buffer[0] = import_shared_types.Protocol.ERROR;
    import_schema.encode.number(packr.buffer, code, it);
    import_schema.encode.string(packr.buffer, message, it);
    return Buffer.from(packr.buffer.subarray(0, it.offset));
  },
  [import_shared_types.Protocol.ROOM_STATE]: (bytes) => {
    return [import_shared_types.Protocol.ROOM_STATE, ...bytes];
  },
  [import_shared_types.Protocol.PING]: () => {
    packr.buffer[0] = import_shared_types.Protocol.PING;
    return Buffer.from(packr.buffer.subarray(0, 1));
  },
  raw: (code, type, message, rawMessage) => {
    const it = { offset: 1 };
    packr.buffer[0] = code;
    if (typeof type === "string") {
      import_schema.encode.string(packr.buffer, type, it);
    } else {
      import_schema.encode.number(packr.buffer, type, it);
    }
    if (message !== void 0) {
      packr.position = 0;
      if (process.env.NODE_ENV !== "production") {
        packr.useBuffer(packr.buffer);
      }
      const endOfBufferOffset = packr.pack(message, 2048 + it.offset).byteLength;
      return Buffer.from(packr.buffer.subarray(0, endOfBufferOffset));
    } else if (rawMessage !== void 0) {
      if (rawMessage.length + it.offset > packr.buffer.byteLength) {
        packr.useBuffer(Buffer.alloc(it.offset + rawMessage.length, packr.buffer));
      }
      packr.buffer.set(rawMessage, it.offset);
      return Buffer.from(packr.buffer.subarray(0, it.offset + rawMessage.byteLength));
    } else {
      return Buffer.from(packr.buffer.subarray(0, it.offset));
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  IpcProtocol,
  getMessageBytes
});
