{
  "version": 3,
  "sources": ["../src/Transport.ts"],
  "sourcesContent": ["import * as http from 'http';\nimport * as https from 'https';\n\nimport type { Router } from '@colyseus/better-call';\n\nimport { ErrorCode } from '@colyseus/shared-types';\nimport { StateView } from '@colyseus/schema';\n\nimport { EventEmitter } from 'events';\nimport { spliceOne } from './utils/Utils.ts';\nimport { ServerError } from './errors/ServerError.ts';\n\nimport type { Room } from './Room.ts';\n\nlet _transport: Transport | undefined;\nexport function setTransport(transport: Transport) { _transport = transport; }\nexport function getTransport() { return _transport; }\n\nexport abstract class Transport {\n    public protocol?: string;\n    public server?: http.Server | https.Server;\n\n    public abstract listen(port?: number | string, hostname?: string, backlog?: number, listeningListener?: Function): this;\n    public abstract shutdown(): void;\n\n    public abstract simulateLatency(milliseconds: number): void;\n\n    /**\n     * Returns an Express-compatible application for HTTP route handling.\n     * For uWebSockets transport, this uses the uwebsockets-express module.\n     * This method is called lazily only when an express callback is provided in server options.\n     */\n    public getExpressApp?(): Promise<import('express').Application> | import('express').Application | undefined;\n\n    /**\n     * Binds a router to the transport.\n     * Some transports may have a custom way to bind a router to the transport.\n     * (uWebSocketsTransport)\n     */\n    public bindRouter?(router: Router): void;\n}\n\nexport type AuthContext = {\n  token?: string,\n  headers: Headers,\n  ip: string | string[];\n  // FIXME: each transport may have its own specific properties.\n  // \"req\" only applies to WebSocketTransport.\n  req?: any;\n};\n\nexport interface ISendOptions {\n  afterNextPatch?: boolean;\n}\n\nexport const ClientState = {\n  JOINING: 0,\n  JOINED: 1,\n  RECONNECTING: 2,\n  RECONNECTED: 3,\n  LEAVING: 4,\n  CLOSED: 5\n} as const;\nexport type ClientState = (typeof ClientState)[keyof typeof ClientState];\n\n// Helper types to extract properties from the Client type parameter\ntype ExtractClientUserData<T> = T extends { userData: infer U } ? U : T;\ntype ExtractClientAuth<T> = T extends { auth: infer A } ? A : any;\ntype ExtractClientMessages<T> = T extends { messages: infer M } ? M : any;\n\n// Helper type to make message required when the message type demands it\nexport type MessageArgs<M, Options> =\n  unknown extends M ? [message?: M, options?: Options] :  // Handle 'any' type (backwards compatibility)\n  [M] extends [never] ? [message?: M, options?: Options] :\n  [M] extends [void] ? [message?: M, options?: Options] :\n  [M] extends [undefined] ? [message?: M, options?: Options] :\n  undefined extends M ? [message?: M, options?: Options] :\n  [message: M, options?: Options];\n\n/**\n * The client instance from the server-side is responsible for the transport layer between the server and the client.\n * It should not be confused with the Client from the client-side SDK, as they have completely different purposes!\n * You operate on client instances from `this.clients`, `Room#onJoin()`, `Room#onLeave()` and `Room#onMessage()`.\n *\n * - This is the raw WebSocket connection coming from the `ws` package. There are more methods available which aren't\n *  encouraged to use along with Colyseus.\n */\nexport interface Client<T extends { userData?: any, auth?: any, messages?: Record<string | number, any> } = any> {\n  '~messages': ExtractClientMessages<T>;\n\n  ref: EventEmitter;\n\n  /**\n   * @deprecated use `sessionId` instead.\n   */\n  id: string;\n\n  /**\n   * Unique id per session.\n   */\n  sessionId: string; // TODO: remove sessionId on version 1.0.0\n\n  /**\n   * Connection state\n   */\n  state: ClientState;\n\n  /**\n   * Optional: when using `@view()` decorator in your state properties, this will be the view instance for this client.\n   */\n  view?: StateView;\n\n  /**\n   * User-defined data can be attached to the Client instance through this variable.\n   * - Can be used to store custom data about the client's connection. userData is not synchronized with the client,\n   * and should be used only to keep player-specific with its connection.\n   */\n  userData?: ExtractClientUserData<T>;\n\n  /**\n   * auth data provided by your `onAuth`\n   */\n  auth?: ExtractClientAuth<T>;\n\n  /**\n   * Reconnection token used to re-join the room after onLeave + allowReconnection().\n   *\n   * IMPORTANT:\n   *    This is not the full reconnection token the client provides for the server.\n   *    The format provided by .reconnect() from the client-side must follow: \"${roomId}:${reconnectionToken}\"\n   */\n  reconnectionToken: string;\n\n  // TODO: move these to ClientPrivate\n  raw(data: Uint8Array | Buffer, options?: ISendOptions, cb?: (err?: Error) => void): void;\n  enqueueRaw(data: Uint8Array | Buffer, options?: ISendOptions): void;\n\n  /**\n   * Send a type of message to the client. Messages are encoded with MsgPack and can hold any\n   * JSON-serializable data structure.\n   *\n   * @param type String or Number identifier the client SDK will use to receive this message\n   * @param message Message payload. (automatically encoded with msgpack.)\n   * @param options\n   */\n  send<K extends keyof this['~messages']>(\n    type: K,\n    ...args: MessageArgs<this['~messages'][K], ISendOptions>\n  ): void;\n\n  /**\n   * Send raw bytes to this specific client.\n   *\n   * @param type String or Number identifier the client SDK will use to receive this message\n   * @param bytes Raw byte array payload\n   * @param options\n   */\n  sendBytes(type: string | number, bytes: Buffer | Uint8Array, options?: ISendOptions): void;\n\n  /**\n   * Disconnect this client from the room.\n   *\n   * @param code Custom close code. Default value is 1000.\n   * @param data\n   * @see [Leave room](https://docs.colyseus.io/room#leave-room)\n   */\n  leave(code?: number, data?: string): void;\n\n  /**\n   * @deprecated Use .leave() instead.\n   */\n  close(code?: number, data?: string): void;\n\n  /**\n   * Triggers `onError` with specified code to the client-side.\n   *\n   * @param code\n   * @param message\n   */\n  error(code: number, message?: string): void;\n}\n\n/**\n * Private properties of the Client instance.\n * Only accessible internally by the framework, should not be encouraged/auto-completed for the user.\n *\n * TODO: refactor this.\n * @private\n */\nexport interface ClientPrivate {\n  readyState: number; // TODO: remove readyState on version 1.0.0. Use only \"state\" instead.\n  _enqueuedMessages?: any[];\n  _afterNextPatchQueue: Array<[string | number | Client, ArrayLike<any>]>;\n  _joinedAt: number; // \"elapsedTime\" when the client joined the room.\n\n  /**\n   * Used for rate limiting via maxMessagesPerSecond.\n   */\n  _numMessagesLastSecond?: number;\n  _lastMessageTime?: number;\n}\n\nexport class ClientArray<C extends Client = Client> extends Array<C> {\n  public getById(sessionId: string): C | undefined {\n    return this.find((client) => client.sessionId === sessionId);\n  }\n\n  public delete(client: C): boolean {\n    return spliceOne(this, this.indexOf(client));\n  }\n}\n\n/**\n * Shared internal method to connect a Client into a Room.\n * Validates seat reservation and joins the client to the room.\n *\n * @remarks\n * **\u26A0\uFE0F This is an internal API and not intended for end-user use.**\n *\n * @internal\n */\nexport async function connectClientToRoom(\n  room: Room | undefined,\n  client: Client & ClientPrivate,\n  authContext: AuthContext,\n  connectionOptions: {\n    reconnectionToken?: string;\n    skipHandshake?: boolean;\n  },\n): Promise<void> {\n  if (!room || !room.hasReservedSeat(client.sessionId, connectionOptions.reconnectionToken)) {\n    throw new ServerError(ErrorCode.MATCHMAKE_EXPIRED, 'seat reservation expired.');\n  }\n\n  await room['_onJoin'](client, authContext, connectionOptions);\n}"],
  "mappings": ";AAAA,OAAsB;AACtB,OAAuB;AAIvB,SAAS,iBAAiB;AAC1B,OAA0B;AAE1B,OAA6B;AAC7B,SAAS,iBAAiB;AAC1B,SAAS,mBAAmB;AAI5B,IAAI;AACG,SAAS,aAAa,WAAsB;AAAE,eAAa;AAAW;AACtE,SAAS,eAAe;AAAE,SAAO;AAAY;AAE7C,IAAe,YAAf,MAAyB;AAsBhC;AAeO,IAAM,cAAc;AAAA,EACzB,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,cAAc;AAAA,EACd,aAAa;AAAA,EACb,SAAS;AAAA,EACT,QAAQ;AACV;AA4IO,IAAM,cAAN,cAAqD,MAAS;AAAA,EAC5D,QAAQ,WAAkC;AAC/C,WAAO,KAAK,KAAK,CAAC,WAAW,OAAO,cAAc,SAAS;AAAA,EAC7D;AAAA,EAEO,OAAO,QAAoB;AAChC,WAAO,UAAU,MAAM,KAAK,QAAQ,MAAM,CAAC;AAAA,EAC7C;AACF;AAWA,eAAsB,oBACpB,MACA,QACA,aACA,mBAIe;AACf,MAAI,CAAC,QAAQ,CAAC,KAAK,gBAAgB,OAAO,WAAW,kBAAkB,iBAAiB,GAAG;AACzF,UAAM,IAAI,YAAY,UAAU,mBAAmB,2BAA2B;AAAA,EAChF;AAEA,QAAM,KAAK,SAAS,EAAE,QAAQ,aAAa,iBAAiB;AAC9D;",
  "names": []
}
