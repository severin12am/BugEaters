{
  "version": 3,
  "sources": ["../../../src/matchmaker/LocalDriver/LocalDriver.ts"],
  "sourcesContent": ["import { debugMatchMaking } from '../../Debug.ts';\nimport type { IRoomCache, SortOptions, MatchMakerDriver } from '../driver.ts';\nimport { Query } from './Query.ts';\n\n// re-export\nexport type { IRoomCache, SortOptions, MatchMakerDriver };\n\nexport class LocalDriver implements MatchMakerDriver {\n  public rooms: IRoomCache[] = [];\n\n  public has(roomId: string) {\n    return this.rooms.some((room) => room.roomId === roomId);\n  }\n\n  public query(conditions: Partial<IRoomCache>, sortOptions?: SortOptions) {\n    const query = new Query<IRoomCache>(this.rooms, conditions);\n\n    if (sortOptions) {\n      query.sort(sortOptions);\n    }\n\n    return query.filter(conditions);\n  }\n\n  public cleanup(processId: string) {\n    const cachedRooms = this.query({ processId });\n    debugMatchMaking(\"removing stale rooms by processId %s (%s rooms found)\", processId, cachedRooms.length);\n\n    cachedRooms.forEach((room) => this.remove(room.roomId));\n    return Promise.resolve();\n  }\n\n  public findOne(conditions: Partial<IRoomCache>, sortOptions?: SortOptions) {\n    const query = new Query<IRoomCache>(this.rooms, conditions);\n\n    if (sortOptions) {\n      query.sort(sortOptions);\n    }\n\n    return query as unknown as Promise<IRoomCache>;\n  }\n\n  public update(room: IRoomCache, operations: Partial<{ $set: Partial<IRoomCache>, $inc: Partial<IRoomCache> }>) {\n    if (operations.$set) {\n      for (const field in operations.$set) {\n        if (operations.$set.hasOwnProperty(field)) {\n          room[field] = operations.$set[field];\n        }\n      }\n    }\n\n    if (operations.$inc) {\n      for (const field in operations.$inc) {\n        if (operations.$inc.hasOwnProperty(field)) {\n          room[field] += operations.$inc[field];\n        }\n      }\n    }\n\n    return true;\n  }\n\n  public persist(room: IRoomCache, create: boolean = false) {\n    // if (this.rooms.indexOf(room) !== -1) {\n    //   // already in the list\n    //   return true;\n    // }\n\n    if (!create) { return false; }\n\n    // add to the list\n    this.rooms.push(room);\n\n    return true;\n  }\n\n  public remove(roomId: string) {\n    const roomIndex = this.rooms.findIndex((room) => room.roomId === roomId);\n    if (roomIndex !== -1) {\n      this.rooms.splice(roomIndex, 1);\n      return true;\n    }\n    return false;\n  }\n\n  public clear() {\n    this.rooms = [];\n  }\n\n  public shutdown() {\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAiC;AAEjC,mBAAsB;AAKf,IAAM,cAAN,MAA8C;AAAA,EAA9C;AACL,SAAO,QAAsB,CAAC;AAAA;AAAA,EAEvB,IAAI,QAAgB;AACzB,WAAO,KAAK,MAAM,KAAK,CAAC,SAAS,KAAK,WAAW,MAAM;AAAA,EACzD;AAAA,EAEO,MAAM,YAAiC,aAA2B;AACvE,UAAM,QAAQ,IAAI,mBAAkB,KAAK,OAAO,UAAU;AAE1D,QAAI,aAAa;AACf,YAAM,KAAK,WAAW;AAAA,IACxB;AAEA,WAAO,MAAM,OAAO,UAAU;AAAA,EAChC;AAAA,EAEO,QAAQ,WAAmB;AAChC,UAAM,cAAc,KAAK,MAAM,EAAE,UAAU,CAAC;AAC5C,uCAAiB,yDAAyD,WAAW,YAAY,MAAM;AAEvG,gBAAY,QAAQ,CAAC,SAAS,KAAK,OAAO,KAAK,MAAM,CAAC;AACtD,WAAO,QAAQ,QAAQ;AAAA,EACzB;AAAA,EAEO,QAAQ,YAAiC,aAA2B;AACzE,UAAM,QAAQ,IAAI,mBAAkB,KAAK,OAAO,UAAU;AAE1D,QAAI,aAAa;AACf,YAAM,KAAK,WAAW;AAAA,IACxB;AAEA,WAAO;AAAA,EACT;AAAA,EAEO,OAAO,MAAkB,YAA+E;AAC7G,QAAI,WAAW,MAAM;AACnB,iBAAW,SAAS,WAAW,MAAM;AACnC,YAAI,WAAW,KAAK,eAAe,KAAK,GAAG;AACzC,eAAK,KAAK,IAAI,WAAW,KAAK,KAAK;AAAA,QACrC;AAAA,MACF;AAAA,IACF;AAEA,QAAI,WAAW,MAAM;AACnB,iBAAW,SAAS,WAAW,MAAM;AACnC,YAAI,WAAW,KAAK,eAAe,KAAK,GAAG;AACzC,eAAK,KAAK,KAAK,WAAW,KAAK,KAAK;AAAA,QACtC;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EAEO,QAAQ,MAAkB,SAAkB,OAAO;AAMxD,QAAI,CAAC,QAAQ;AAAE,aAAO;AAAA,IAAO;AAG7B,SAAK,MAAM,KAAK,IAAI;AAEpB,WAAO;AAAA,EACT;AAAA,EAEO,OAAO,QAAgB;AAC5B,UAAM,YAAY,KAAK,MAAM,UAAU,CAAC,SAAS,KAAK,WAAW,MAAM;AACvE,QAAI,cAAc,IAAI;AACpB,WAAK,MAAM,OAAO,WAAW,CAAC;AAC9B,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA,EAEO,QAAQ;AACb,SAAK,QAAQ,CAAC;AAAA,EAChB;AAAA,EAEO,WAAW;AAAA,EAClB;AACF;",
  "names": []
}
