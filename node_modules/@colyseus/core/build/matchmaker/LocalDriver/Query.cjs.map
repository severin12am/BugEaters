{
  "version": 3,
  "sources": ["../../../src/matchmaker/LocalDriver/Query.ts"],
  "sourcesContent": ["import type { IRoomCache, SortOptions } from '../driver.ts';\n\nexport class Query<T extends IRoomCache> {\n  private $rooms: T[];\n  private conditions: any;\n  private sortOptions?: SortOptions;\n\n  constructor(rooms: any[], conditions) {\n    this.$rooms = rooms.slice(0);\n    this.conditions = conditions;\n  }\n\n  public sort(options: SortOptions) {\n    // Store sort options instead of sorting immediately\n    // This allows filtering first, then sorting fewer items\n    this.sortOptions = options;\n    return this;\n  }\n\n  private applySort(rooms: T[]): T[] {\n    if (!this.sortOptions) {\n      return rooms;\n    }\n\n    return rooms.sort((room1: T, room2: T) => {\n      for (const field in this.sortOptions) {\n        const direction = this.sortOptions[field];\n        if (room1.hasOwnProperty(field)) {\n          /**\n           * IRoomCache field\n           */\n          if (direction === 1 || direction === 'asc' || direction === 'ascending') {\n            if (room1[field] > room2[field]) { return 1; }\n            if (room1[field] < room2[field]) { return -1; }\n\n          } else {\n            if (room1[field] > room2[field]) { return -1; }\n            if (room1[field] < room2[field]) { return 1; }\n          }\n        } else if (room1.metadata?.hasOwnProperty(field)) {\n          /**\n           * metadata field\n           */\n          if (direction === 1 || direction === 'asc' || direction === 'ascending') {\n            if (room1.metadata[field] > room2.metadata[field]) { return 1; }\n            if (room1.metadata[field] < room2.metadata[field]) { return -1; }\n          } else {\n            if (room1.metadata[field] > room2.metadata[field]) { return -1; }\n            if (room1.metadata[field] < room2.metadata[field]) { return 1; }\n          }\n        }\n      }\n      return 0;\n    });\n  }\n\n  private applyFilter(rooms: T[], conditions: any): T[] {\n    return rooms.filter(((room) => {\n      for (const field in conditions) {\n        if (conditions.hasOwnProperty(field)) {\n          // Check if field exists in room (IRoomCache base fields)\n          if (room.hasOwnProperty(field)) {\n            if (room[field] !== conditions[field]) {\n              return false;\n            }\n          } else if (room.metadata?.hasOwnProperty(field)) {\n            // Check if field exists in metadata\n            if (room.metadata[field] !== conditions[field]) {\n              return false;\n            }\n          } else {\n            // Field doesn't exist in room or metadata\n            return false;\n          }\n        }\n      }\n      return true;\n    }));\n  }\n\n  public filter(conditions: any) {\n    // Filter first to reduce the number of items to sort\n    const filtered = this.applyFilter(this.$rooms, conditions);\n    return this.applySort(filtered);\n  }\n\n  public then(resolve, reject) {\n    // Filter first to reduce the number of items to sort\n    const filtered = this.applyFilter(this.$rooms, this.conditions);\n    const sorted = this.applySort(filtered);\n    const result: any = sorted[0];\n    return resolve(result);\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEO,IAAM,QAAN,MAAkC;AAAA,EAKvC,YAAY,OAAc,YAAY;AACpC,SAAK,SAAS,MAAM,MAAM,CAAC;AAC3B,SAAK,aAAa;AAAA,EACpB;AAAA,EAEO,KAAK,SAAsB;AAGhC,SAAK,cAAc;AACnB,WAAO;AAAA,EACT;AAAA,EAEQ,UAAU,OAAiB;AACjC,QAAI,CAAC,KAAK,aAAa;AACrB,aAAO;AAAA,IACT;AAEA,WAAO,MAAM,KAAK,CAAC,OAAU,UAAa;AACxC,iBAAW,SAAS,KAAK,aAAa;AACpC,cAAM,YAAY,KAAK,YAAY,KAAK;AACxC,YAAI,MAAM,eAAe,KAAK,GAAG;AAI/B,cAAI,cAAc,KAAK,cAAc,SAAS,cAAc,aAAa;AACvE,gBAAI,MAAM,KAAK,IAAI,MAAM,KAAK,GAAG;AAAE,qBAAO;AAAA,YAAG;AAC7C,gBAAI,MAAM,KAAK,IAAI,MAAM,KAAK,GAAG;AAAE,qBAAO;AAAA,YAAI;AAAA,UAEhD,OAAO;AACL,gBAAI,MAAM,KAAK,IAAI,MAAM,KAAK,GAAG;AAAE,qBAAO;AAAA,YAAI;AAC9C,gBAAI,MAAM,KAAK,IAAI,MAAM,KAAK,GAAG;AAAE,qBAAO;AAAA,YAAG;AAAA,UAC/C;AAAA,QACF,WAAW,MAAM,UAAU,eAAe,KAAK,GAAG;AAIhD,cAAI,cAAc,KAAK,cAAc,SAAS,cAAc,aAAa;AACvE,gBAAI,MAAM,SAAS,KAAK,IAAI,MAAM,SAAS,KAAK,GAAG;AAAE,qBAAO;AAAA,YAAG;AAC/D,gBAAI,MAAM,SAAS,KAAK,IAAI,MAAM,SAAS,KAAK,GAAG;AAAE,qBAAO;AAAA,YAAI;AAAA,UAClE,OAAO;AACL,gBAAI,MAAM,SAAS,KAAK,IAAI,MAAM,SAAS,KAAK,GAAG;AAAE,qBAAO;AAAA,YAAI;AAChE,gBAAI,MAAM,SAAS,KAAK,IAAI,MAAM,SAAS,KAAK,GAAG;AAAE,qBAAO;AAAA,YAAG;AAAA,UACjE;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAAA,EAEQ,YAAY,OAAY,YAAsB;AACpD,WAAO,MAAM,QAAQ,CAAC,SAAS;AAC7B,iBAAW,SAAS,YAAY;AAC9B,YAAI,WAAW,eAAe,KAAK,GAAG;AAEpC,cAAI,KAAK,eAAe,KAAK,GAAG;AAC9B,gBAAI,KAAK,KAAK,MAAM,WAAW,KAAK,GAAG;AACrC,qBAAO;AAAA,YACT;AAAA,UACF,WAAW,KAAK,UAAU,eAAe,KAAK,GAAG;AAE/C,gBAAI,KAAK,SAAS,KAAK,MAAM,WAAW,KAAK,GAAG;AAC9C,qBAAO;AAAA,YACT;AAAA,UACF,OAAO;AAEL,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT,EAAE;AAAA,EACJ;AAAA,EAEO,OAAO,YAAiB;AAE7B,UAAM,WAAW,KAAK,YAAY,KAAK,QAAQ,UAAU;AACzD,WAAO,KAAK,UAAU,QAAQ;AAAA,EAChC;AAAA,EAEO,KAAK,SAAS,QAAQ;AAE3B,UAAM,WAAW,KAAK,YAAY,KAAK,QAAQ,KAAK,UAAU;AAC9D,UAAM,SAAS,KAAK,UAAU,QAAQ;AACtC,UAAM,SAAc,OAAO,CAAC;AAC5B,WAAO,QAAQ,MAAM;AAAA,EACvB;AACF;",
  "names": []
}
