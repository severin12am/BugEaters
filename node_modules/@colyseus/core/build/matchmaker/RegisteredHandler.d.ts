import { EventEmitter } from 'events';
import { Room } from './../Room.ts';
import type { IRoomCache, SortOptions, IRoomCacheFilterByKeys, IRoomCacheSortByKeys, ExtractRoomCacheMetadata } from './driver.ts';
import type { Client } from '../Transport.ts';
import type { Type } from "../utils/Utils.ts";
export declare const INVALID_OPTION_KEYS: Array<keyof IRoomCache>;
/**
 * Type for filterBy that supports both onCreate options and metadata fields
 */
type FilterByKeys<RoomType extends Room> = IRoomCacheFilterByKeys | (ExtractRoomCacheMetadata<RoomType> extends object ? keyof ExtractRoomCacheMetadata<RoomType> & string : never);
/**
 * Type for sortBy that supports room cache fields and metadata fields
 */
type SortByKeys<RoomType extends Room> = IRoomCacheSortByKeys | (ExtractRoomCacheMetadata<RoomType> extends object ? keyof ExtractRoomCacheMetadata<RoomType> & string : never);
export interface RegisteredHandlerEvents<RoomType extends Room = any> {
    create: [room: RoomType];
    lock: [room: RoomType];
    unlock: [room: RoomType];
    join: [room: RoomType, client: Client];
    leave: [room: RoomType, client: Client, willDispose: boolean];
    dispose: [room: RoomType];
    'visibility-change': [room: RoomType, isVisible: boolean];
    'metadata-change': [room: RoomType];
}
export declare class RegisteredHandler<RoomType extends Room = any> extends EventEmitter<RegisteredHandlerEvents<RoomType>> {
    '~room': RoomType;
    klass: Type<RoomType>;
    options: any;
    name: string;
    filterOptions: Array<FilterByKeys<RoomType>>;
    sortOptions?: SortOptions;
    realtimeListingEnabled: boolean;
    constructor(klass: Type<RoomType>, options?: any);
    enableRealtimeListing(): this;
    /**
     * Define which fields should be used for filtering rooms.
     * Supports both onCreate options and metadata fields using dot notation.
     *
     * @example
     * // Filter by IRoomCache fields
     * .filterBy(['maxClients'])
     *
     * @example
     * // Filter by metadata fields
     * .filterBy(['difficulty', 'metadata.region'])
     *
     * @example
     * // Mix both
     * .filterBy(['mode', 'difficulty', 'maxClients'])
     */
    filterBy<T extends FilterByKeys<RoomType>>(options: T[]): this;
    /**
     * Define how rooms should be sorted when querying.
     * Supports both room cache fields and metadata fields using dot notation.
     *
     * @example
     * // Sort by number of clients (descending)
     * .sortBy({ clients: -1 })
     *
     * @example
     * // Sort by metadata field
     * .sortBy({ 'metadata.rating': -1 })
     *
     * @example
     * // Multiple sort criteria
     * .sortBy({ 'metadata.skillLevel': 1, clients: -1 })
     */
    sortBy<T extends SortByKeys<RoomType>>(options: {
        [K in T]: SortOptions[string];
    }): this;
    getMetadataFromOptions(options: any): {
        metadata: {};
    } | {
        metadata?: undefined;
    };
    /**
     * Extract filter options from client options.
     */
    getFilterOptions(options: any): {};
}
export {};
