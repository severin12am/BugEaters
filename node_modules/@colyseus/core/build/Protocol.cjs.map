{
  "version": 3,
  "sources": ["../src/Protocol.ts"],
  "sourcesContent": ["import { Packr } from '@colyseus/msgpackr';\nimport { encode, type Iterator } from '@colyseus/schema';\nimport { Protocol } from '@colyseus/shared-types';\n\n// Inter-process communication protocol\nexport const IpcProtocol = {\n  SUCCESS: 0,\n  ERROR: 1,\n  TIMEOUT: 2,\n} as const;\nexport type IpcProtocol = typeof IpcProtocol[keyof typeof IpcProtocol];\n\nconst packr = new Packr({\n  useRecords: false, // increased compatibility with decoders other than \"msgpackr\"\n});\n\n// msgpackr workaround: initialize buffer\npackr.encode(undefined);\n\nexport const getMessageBytes = {\n  [Protocol.JOIN_ROOM]: (reconnectionToken: string, serializerId: string, handshake?: Uint8Array) => {\n    const it: Iterator = { offset: 1 };\n    packr.buffer[0] = Protocol.JOIN_ROOM;\n\n    packr.buffer[it.offset++] = Buffer.byteLength(reconnectionToken, \"utf8\");\n    encode.utf8Write(packr.buffer, reconnectionToken, it);\n\n    packr.buffer[it.offset++] = Buffer.byteLength(serializerId, \"utf8\");\n    encode.utf8Write(packr.buffer, serializerId, it);\n\n    let handshakeLength = handshake?.byteLength || 0;\n\n    // check if buffer needs to be resized\n    if (handshakeLength > packr.buffer.byteLength - it.offset) {\n      packr.useBuffer(Buffer.alloc(it.offset + handshakeLength, packr.buffer));\n    }\n\n    if (handshakeLength > 0) {\n      packr.buffer.set(handshake, it.offset);\n    }\n\n    return Buffer.from(packr.buffer.subarray(0, it.offset + handshakeLength));\n  },\n\n  [Protocol.ERROR]: (code: number, message: string = '') => {\n    const it: Iterator = { offset: 1 };\n    packr.buffer[0] = Protocol.ERROR;\n\n    encode.number(packr.buffer, code, it);\n    encode.string(packr.buffer, message, it);\n\n    return Buffer.from(packr.buffer.subarray(0, it.offset));\n  },\n\n  [Protocol.ROOM_STATE]: (bytes: number[]) => {\n    return [Protocol.ROOM_STATE, ...bytes];\n  },\n\n  [Protocol.PING]: () => {\n    packr.buffer[0] = Protocol.PING;\n    return Buffer.from(packr.buffer.subarray(0, 1));\n  },\n\n  raw: (code: Protocol, type: string | number, message?: any, rawMessage?: Uint8Array | Buffer) => {\n    const it: Iterator = { offset: 1 };\n    packr.buffer[0] = code;\n\n    if (typeof (type) === 'string') {\n      encode.string(packr.buffer, type, it);\n\n    } else {\n      encode.number(packr.buffer, type, it);\n    }\n\n    if (message !== undefined) {\n      // force to encode from offset\n      packr.position = 0;\n\n      //\n      // TODO: remove this after issue is fixed https://github.com/kriszyp/msgpackr/issues/139\n      //\n      // - This check is only required when running integration tests.\n      //   (colyseus.js' usage of msgpackr/buffer is conflicting)\n      //\n      if (process.env.NODE_ENV !== \"production\") {\n        packr.useBuffer(packr.buffer);\n      }\n\n      // pack message into the same packr.buffer\n      const endOfBufferOffset = packr.pack(message, 2048 + it.offset).byteLength;\n                                                 // 2048 = RESERVE_START_SPACE\n      return Buffer.from(packr.buffer.subarray(0, endOfBufferOffset));\n\n    } else if (rawMessage !== undefined) {\n\n      // check if buffer needs to be resized\n      // TODO: can we avoid this?\n      if (rawMessage.length + it.offset > packr.buffer.byteLength) {\n        packr.useBuffer(Buffer.alloc(it.offset + rawMessage.length, packr.buffer));\n      }\n\n      // copy raw message into packr.buffer\n      packr.buffer.set(rawMessage, it.offset);\n\n      return Buffer.from(packr.buffer.subarray(0, it.offset + rawMessage.byteLength));\n\n    } else {\n      return Buffer.from(packr.buffer.subarray(0, it.offset));\n    }\n  },\n\n};\n\n"],
  "mappings": "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",
  "names": []
}
