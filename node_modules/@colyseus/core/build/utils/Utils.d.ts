import { type RoomException, type RoomMethodName } from '../errors/RoomExceptions.ts';
export type Type<T> = new (...args: any[]) => T;
export type MethodName<T> = string & {
    [K in keyof T]: T[K] extends (...args: any[]) => any ? K : never;
}[keyof T];
/**
 * Utility type that extracts the return type of a method or the type of a property
 * from a given class/object type.
 *
 * - If the key is a method, returns the awaited return type of that method
 * - If the key is a property, returns the type of that property
 */
export type ExtractMethodOrPropertyType<TClass, TKey extends keyof TClass> = TClass[TKey] extends (...args: any[]) => infer R ? Awaited<R> : TClass[TKey];
export declare const REMOTE_ROOM_SHORT_TIMEOUT: number;
export declare const MAX_CONCURRENT_CREATE_ROOM_WAIT_TIME: number;
export declare function generateId(length?: number): string;
export declare function getBearerToken(authHeader: string): string;
export declare function registerGracefulShutdown(callback: (err?: Error) => void): void;
export declare function retry<T = any>(cb: Function, maxRetries?: number, errorWhiteList?: any[], retries?: number): Promise<T>;
export declare function spliceOne(arr: any[], index: number): boolean;
export declare class Deferred<T = any> {
    promise: Promise<T>;
    resolve: Function;
    reject: Function;
    constructor(promise?: Promise<T>);
    then(onFulfilled?: (value: T) => any, onRejected?: (reason: any) => any): Promise<any>;
    catch(func: (value: any) => any): Promise<any>;
    static reject(reason?: any): Deferred<never>;
    static resolve<T = any>(value?: T): Deferred<T>;
}
export declare function merge(a: any, ...objs: any[]): any;
export declare function wrapTryCatch(method: Function, onError: (error: RoomException, methodName: RoomMethodName) => void, exceptionClass: Type<RoomException>, methodName: RoomMethodName, rethrow?: boolean, ...additionalErrorArgs: any[]): (...args: any[]) => any;
/**
 * Dynamically import a module using either require() or import()
 * based on the current module system (CJS vs ESM).
 *
 * This avoids double-loading packages when running in mixed ESM/CJS environments.
 * Errors are silently caught - await the promise and handle errors at usage site.
 */
export declare function dynamicImport<T = any>(moduleName: string): Promise<T>;
