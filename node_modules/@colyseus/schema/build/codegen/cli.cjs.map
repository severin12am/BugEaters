{"version":3,"file":"cli.cjs","sources":["../../src/codegen/argv.ts","../../src/codegen/types.ts","../../src/codegen/parser.ts","../../src/codegen/languages/csharp.ts","../../src/codegen/languages/cpp.ts","../../src/codegen/languages/haxe.ts","../../src/codegen/languages/ts.ts","../../src/codegen/languages/js.ts","../../src/codegen/languages/java.ts","../../src/codegen/languages/lua.ts","../../src/codegen/languages/c.ts","../../src/codegen/languages/gdscript.ts","../../src/codegen/api.ts","../../src/codegen/cli.ts"],"sourcesContent":["/**\n * @author Ethan Davis\n * https://github.com/ethanent/gar\n */\nexport default (sargs: string[]): any => {\n\tlet props: any = {}\n\tlet lones: any = []\n\n\tconst convertIfApplicable = (value: any) => (isNaN(value) ? (value.toString().toLowerCase() === 'true' ? true : (value.toString().toLowerCase() === 'false' ? false : value)) : Number(value))\n\tconst removeStartHyphens = (value: string) => value.replace(/^\\-+/g, '')\n\n\tfor (let i = 0; i < sargs.length; i++) {\n\t\tconst equalsIndex = sargs[i].indexOf('=')\n\t\tconst isNextRefProp = sargs[i].charAt(0) === '-' && sargs.length - 1 >= i + 1 && sargs[i + 1].indexOf('=') === -1 && sargs[i + 1].charAt(0) !== '-'\n\t\tconst argName = equalsIndex === -1 ? removeStartHyphens(sargs[i]) : removeStartHyphens(sargs[i].slice(0, equalsIndex))\n\n\t\tif (equalsIndex !== -1) {\n\t\t\tprops[argName] = convertIfApplicable(sargs[i].slice(equalsIndex + 1))\n\t\t}\n\t\telse if (isNextRefProp) {\n\t\t\tprops[argName] = convertIfApplicable(sargs[i + 1])\n\t\t\ti++\n\t\t} else if (sargs[i].charAt(0) === '-') {\n\t\t\tif (sargs[i].charAt(1) === '-') {\n\t\t\t\tprops[argName] = true\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (let b = 0; b < argName.length; b++) {\n\t\t\t\t\tprops[argName.charAt(b)] = true\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlones.push(convertIfApplicable(argName))\n\t\t}\n\t}\n\n\treturn Object.assign(props, {\n\t\t'_': lones\n\t})\n}\n","import * as fs from \"fs\";\nimport * as path from \"path\";\n\nif (typeof(__dirname) === \"undefined\") {\n    global.__dirname = path.dirname(new URL(import.meta.url).pathname);\n}\n\nconst VERSION = JSON.parse(fs.readFileSync(__dirname + \"/../../package.json\").toString()).version;\nconst COMMENT_HEADER = `\nTHIS FILE HAS BEEN GENERATED AUTOMATICALLY\nDO NOT CHANGE IT MANUALLY UNLESS YOU KNOW WHAT YOU'RE DOING\n\nGENERATED USING @colyseus/schema ${VERSION}\n`;\n\nexport function getCommentHeader(singleLineComment: string = \"//\") {\n    return `${COMMENT_HEADER.split(\"\\n\").map(line => `${singleLineComment} ${line}`).join(\"\\n\")}`;\n}\n\nexport class Context {\n    classes: Class[] = [];\n    interfaces: Interface[] = [];\n    enums: Enum[] = [];\n\n    getStructures() {\n        return {\n            classes: this.classes.filter(klass => {\n                if (this.isSchemaClass(klass)) {\n                    return true;\n\n                } else {\n                    let parentClass = klass;\n                    while (parentClass = this.getParentClass(parentClass)) {\n                        if (this.isSchemaClass(parentClass)) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }),\n            interfaces: this.interfaces,\n            enums: this.enums,\n        };\n    }\n\n    addStructure(structure: IStructure) {\n        if (structure.context === this) { return; } // skip if already added.\n        structure.context = this;\n\n        if (structure instanceof Class) {\n            this.classes.push(structure);\n        } else if (structure instanceof Interface) {\n            this.interfaces.push(structure);\n        } else if (structure instanceof Enum) {\n            this.enums.push(structure);\n        }\n    }\n\n    private getParentClass(klass: Class) {\n        return this.classes.find(c => c.name === klass.extends);\n    }\n\n    private isSchemaClass(klass: Class) {\n        let isSchema: boolean = false;\n\n        let currentClass = klass;\n        while (!isSchema && currentClass) {\n            //\n            // TODO: ideally we should check for actual @colyseus/schema module\n            // reference rather than arbitrary strings.\n            //\n            isSchema = (\n                currentClass.extends === \"Schema\" ||\n                currentClass.extends === \"schema.Schema\" ||\n                currentClass.extends === \"Schema.Schema\"\n            );\n\n            //\n            // When extending from `schema.Schema`, it is required to\n            // normalize as \"Schema\" for code generation.\n            //\n            if (currentClass === klass && isSchema) {\n                klass.extends = \"Schema\";\n            }\n\n            currentClass = this.getParentClass(currentClass);\n        }\n\n        return isSchema;\n    }\n}\n\nexport interface IStructure {\n    context: Context;\n    name: string;\n    properties: Property[];\n    addProperty(property: Property): void;\n}\n\nexport class Interface implements IStructure {\n    context: Context;\n    name: string;\n    properties: Property[] = [];\n\n    addProperty(property: Property): void {\n        if (property.type.indexOf(\"[]\") >= 0) {\n            // is array!\n            property.childType = property.type.match(/([^\\[]+)/i)[1];\n            property.type = \"array\";\n            this.properties.push(property);\n\n        } else {\n            this.properties.push(property);\n        }\n    }\n}\n\nexport class Class implements IStructure {\n    context: Context;\n    name: string;\n    properties: Property[] = [];\n    extends: string;\n\n    addProperty(property: Property) {\n        property.index = this.properties.length;\n        this.properties.push(property);\n    }\n\n    postProcessing() {\n        /**\n         * Ensure the proprierties `index` are correct using inheritance\n         */\n        let parentKlass: Class = this;\n\n        while (\n            parentKlass &&\n            (parentKlass = this.context.classes.find(k => k.name === parentKlass.extends))\n        ) {\n            this.properties.forEach(prop => {\n                prop.index += parentKlass.properties.length;\n            });\n        }\n    }\n}\n\nexport class Enum implements IStructure {\n    context: Context;\n    name: string;\n    properties: Property[] = [];\n\n    addProperty(property: Property) {\n        this.properties.push(property);\n    }\n}\n\nexport class Property {\n    index: number;\n    name: string;\n    type: string;\n    childType: string;\n    deprecated?: boolean;\n}\n\nexport interface File {\n    name: string\n    content: string;\n}\n\n/**\n * Structured file representation for code generation.\n * Separates imports, local references, and body content to enable\n * clean bundling without string parsing.\n */\nexport interface GeneratedFile {\n    name: string;\n    /** External imports (e.g., \"@colyseus/schema\", \"Colyseus.Schema\") */\n    imports: string[];\n    /** References to other generated classes (used for imports in non-bundle mode) */\n    localRefs: string[];\n    /** The class/interface/enum definition body (without imports or namespace wrapper) */\n    body: string;\n}\n\nexport function getInheritanceTree(klass: Class, allClasses: Class[], includeSelf: boolean = true) {\n    let currentClass = klass;\n    let inheritanceTree: Class[] = [];\n\n    if (includeSelf) {\n        inheritanceTree.push(currentClass);\n    }\n\n    while (currentClass.extends !== \"Schema\") {\n        currentClass = allClasses.find(klass => klass.name == currentClass.extends);\n        inheritanceTree.push(currentClass);\n    }\n\n    return inheritanceTree;\n}\n","import * as ts from \"typescript\";\nimport * as path from \"path\";\nimport { readFileSync } from \"fs\";\nimport { IStructure, Class, Interface, Property, Context, Enum } from \"./types.js\";\n\nlet currentStructure: IStructure;\nlet currentProperty: Property;\n\nlet globalContext: Context;\n\nfunction defineProperty(property: Property, initializer: any) {\n    if (ts.isIdentifier(initializer)) {\n        property.type = \"ref\";\n        property.childType = initializer.text;\n\n    } else if (initializer.kind == ts.SyntaxKind.ObjectLiteralExpression) {\n        property.type = initializer.properties[0].name.text;\n        property.childType = initializer.properties[0].initializer.text;\n\n    } else if (initializer.kind == ts.SyntaxKind.ArrayLiteralExpression) {\n        property.type = \"array\";\n        property.childType = initializer.elements[0].text;\n\n    } else {\n        property.type = initializer.text;\n    }\n}\n\nfunction inspectNode(node: ts.Node, context: Context, decoratorName: string) {\n    switch (node.kind) {\n        case ts.SyntaxKind.ImportClause:\n            const specifier = (node.parent as any).moduleSpecifier;\n            if (specifier && (specifier.text as string).startsWith('.')) {\n                const currentDir = path.dirname(node.getSourceFile().fileName);\n                const pathToImport = path.resolve(currentDir, specifier.text);\n                parseFiles([pathToImport], decoratorName, globalContext);\n            }\n            break;\n\n        case ts.SyntaxKind.ClassDeclaration:\n            currentStructure = new Class();\n\n            const heritageClauses = (node as ts.ClassLikeDeclarationBase).heritageClauses;\n            if (heritageClauses && heritageClauses.length > 0) {\n                (currentStructure as Class).extends = heritageClauses[0].types[0].expression.getText();\n            }\n\n            context.addStructure(currentStructure);\n            break;\n\n        case ts.SyntaxKind.InterfaceDeclaration:\n            //\n            // Only generate Interfaces if it has \"Message\" on its name.\n            // Example: MyMessage\n            //\n            const interfaceName = (node as ts.TypeParameterDeclaration).name.escapedText.toString();\n            if (interfaceName.indexOf(\"Message\") !== -1) {\n                currentStructure = new Interface();\n                currentStructure.name = interfaceName;\n\n                context.addStructure(currentStructure);\n            }\n            break;\n\n        case ts.SyntaxKind.EnumDeclaration:\n            const enumName = (\n                node as ts.EnumDeclaration\n            ).name.escapedText.toString();\n            currentStructure = new Enum();\n            currentStructure.name = enumName;\n            context.addStructure(currentStructure);\n            break;\n\n        case ts.SyntaxKind.ExtendsKeyword:\n            // console.log(node.getText());\n            break;\n\n        case ts.SyntaxKind.PropertySignature:\n            if (currentStructure instanceof Interface) {\n                const parent = node.parent;\n\n                // Only process direct children of InterfaceDeclaration, skip TypeLiterals\n                if (!ts.isInterfaceDeclaration(parent)) {\n                    break;\n                }\n\n                // Skip if property if for a another interface than the one we're interested in.\n                if (currentStructure.name !== parent.name.escapedText.toString()) {\n                    break;\n                }\n\n                // define a property of an interface\n                const property = new Property();\n                property.name = (node as any).name.escapedText.toString();\n                property.type = (node as any).type.getText();\n                currentStructure.addProperty(property);\n            }\n            break;\n\n        case ts.SyntaxKind.Identifier:\n            if (\n                node.getText() === \"deprecated\" &&\n                node.parent.kind !== ts.SyntaxKind.ImportSpecifier\n            ) {\n                currentProperty = new Property();\n                currentProperty.deprecated = true;\n                break;\n            }\n\n            if (node.getText() === decoratorName) {\n                const prop: any = node.parent?.parent?.parent;\n                const propDecorator = getDecorators(prop);\n                const hasExpression = prop?.expression?.arguments;\n                const hasDecorator = (propDecorator?.length > 0);\n\n                /**\n                 * neither a `@type()` decorator or `type()` call. skip.\n                 */\n                if (!hasDecorator && !hasExpression) {\n                    break;\n                }\n\n                // using as decorator\n                if (propDecorator) {\n                    /**\n                     * Calling `@type()` as decorator\n                     */\n                    const typeDecorator: any = propDecorator.find((decorator => {\n                        return (decorator.expression as any).expression.escapedText === decoratorName;\n                    })).expression;\n\n                    const property = currentProperty || new Property();\n                    property.name = prop.name.escapedText;\n                    currentStructure.addProperty(property);\n\n                    const typeArgument = typeDecorator.arguments[0];\n                    defineProperty(property, typeArgument);\n\n                } else if (\n                    prop.expression.arguments?.[1] &&\n                    prop.expression.expression.arguments?.[0]\n                ) {\n                    /**\n                     * Calling `type()` as a regular method\n                     */\n                    const property = currentProperty || new Property();\n                    property.name = prop.expression.arguments[1].text;\n                    currentStructure.addProperty(property);\n\n                    const typeArgument = prop.expression.expression.arguments[0];\n                    defineProperty(property, typeArgument);\n                }\n\n            } else if (\n                node.getText() === \"setFields\" &&\n                (\n                    node.parent.kind === ts.SyntaxKind.CallExpression ||\n                    node.parent.kind === ts.SyntaxKind.PropertyAccessExpression\n                )\n            ) {\n                /**\n                 * Metadata.setFields(klassName, { ... })\n                 */\n                const callExpression = (node.parent.kind === ts.SyntaxKind.PropertyAccessExpression)\n                    ? node.parent.parent as ts.CallExpression\n                    : node.parent as ts.CallExpression;\n\n                /**\n                 * Skip if @codegen-ignore comment is found before the call expression\n                 * TODO: currently, if @codegen-ignore is on the file, it will skip all the setFields calls.\n                 */\n                const sourceFile = node.getSourceFile();\n                const fullText = sourceFile.getFullText();\n                const nodeStart = callExpression.getFullStart();\n                const textBeforeNode = fullText.substring(0, nodeStart);\n                if (textBeforeNode.includes('@codegen-ignore')) {\n                    break;\n                }\n\n                if (callExpression.kind !== ts.SyntaxKind.CallExpression) {\n                    break;\n                }\n\n                const classNameNode = callExpression.arguments[0];\n                const className = ts.isClassExpression(classNameNode)\n                    ? classNameNode.name?.escapedText.toString()\n                    : classNameNode.getText();\n\n                // skip if no className is provided\n                if (!className) { break; }\n\n                if (currentStructure?.name !== className) {\n                    currentStructure = new Class();\n                }\n                context.addStructure(currentStructure);\n                (currentStructure as Class).extends = \"Schema\"; // force extends to Schema\n                currentStructure.name = className;\n\n                const types = callExpression.arguments[1] as any;\n                for (let i = 0; i < types.properties.length; i++) {\n                    const prop = types.properties[i];\n\n                    const property = currentProperty || new Property();\n                    property.name = prop.name.escapedText;\n\n                    currentStructure.addProperty(property);\n                    defineProperty(property, prop.initializer);\n                }\n\n            } else if (\n                node.getText() === \"defineTypes\" &&\n                (\n                    node.parent.kind === ts.SyntaxKind.CallExpression ||\n                    node.parent.kind === ts.SyntaxKind.PropertyAccessExpression\n                )\n            ) {\n                /**\n                 * JavaScript source file (`.js`)\n                 * Using `defineTypes()`\n                 */\n                const callExpression = (node.parent.kind === ts.SyntaxKind.PropertyAccessExpression)\n                    ? node.parent.parent as ts.CallExpression\n                    : node.parent as ts.CallExpression;\n\n                if (callExpression.kind !== ts.SyntaxKind.CallExpression) {\n                    break;\n                }\n\n                const className = callExpression.arguments[0].getText()\n                currentStructure.name = className;\n\n                const types = callExpression.arguments[1] as any;\n                for (let i = 0; i < types.properties.length; i++) {\n                    const prop = types.properties[i];\n\n                    const property = currentProperty || new Property();\n                    property.name = prop.name.escapedText;\n                    currentStructure.addProperty(property);\n\n                    defineProperty(property, prop.initializer);\n                }\n\n            }\n\n            if (node.parent.kind === ts.SyntaxKind.ClassDeclaration) {\n                currentStructure.name = node.getText();\n            }\n\n            currentProperty = undefined;\n\n            break;\n\n        case ts.SyntaxKind.CallExpression:\n            /**\n             * Defining schema via `schema.schema({ ... })`\n             * - schema.schema({})\n             * - schema({})\n             * - ClassName.extends({})\n             */\n            if (\n                (\n                    (\n                        (node as ts.CallExpression).expression?.getText() === \"schema.schema\" ||\n                        (node as ts.CallExpression).expression?.getText() === \"schema\"\n                    ) ||\n                    (\n                        (node as ts.CallExpression).expression?.getText().indexOf(\".extends\") !== -1\n                    )\n                ) &&\n                (node as ts.CallExpression).arguments[0].kind === ts.SyntaxKind.ObjectLiteralExpression\n            ) {\n                const callExpression = node as ts.CallExpression;\n\n                let className = callExpression.arguments[1]?.getText();\n\n                if (!className && callExpression.parent.kind === ts.SyntaxKind.VariableDeclaration) {\n                    className = (callExpression.parent as ts.VariableDeclaration).name?.getText();\n                }\n\n                // skip if no className is provided\n                if (!className) { break; }\n\n                if (currentStructure?.name !== className) {\n                    currentStructure = new Class();\n                    context.addStructure(currentStructure);\n                }\n\n                if ((node as ts.CallExpression).expression?.getText().indexOf(\".extends\") !== -1) {\n                    // if it's using `.extends({})`\n                    const extendsClass = (node as any).expression?.expression?.escapedText;\n\n                    // skip if no extendsClass is provided\n                    if (!extendsClass) { break; }\n                    (currentStructure as Class).extends = extendsClass;\n\n                } else {\n                    // if it's using `schema({})`\n                    (currentStructure as Class).extends = \"Schema\"; // force extends to Schema\n                }\n\n                currentStructure.name = className;\n\n                const types = callExpression.arguments[0] as any;\n                for (let i = 0; i < types.properties.length; i++) {\n                    const prop = types.properties[i];\n\n                    const property = currentProperty || new Property();\n                    property.name = prop.name.escapedText;\n\n                    currentStructure.addProperty(property);\n                    defineProperty(property, prop.initializer);\n                }\n            }\n\n            break;\n\n        case ts.SyntaxKind.EnumMember:\n            if (currentStructure instanceof Enum) {\n                const initializer = (node as any).initializer?.text;\n                const name = node.getFirstToken().getText();\n                const property = currentProperty || new Property();\n                property.name = name;\n                if (initializer !== undefined) {\n                    property.type = initializer;\n                }\n                currentStructure.addProperty(property);\n                currentProperty = undefined;\n            }\n            break;\n    }\n\n    ts.forEachChild(node, (n: ts.Node) => inspectNode(n, context, decoratorName));\n}\n\nlet parsedFiles: { [filename: string]: boolean };\n\nexport function parseFiles(\n    fileNames: string[],\n    decoratorName: string = \"type\",\n    context: Context = new Context()\n) {\n    /**\n     * Re-set globalContext for each test case\n     */\n    if (globalContext !== context) {\n        parsedFiles = {};\n        globalContext = context;\n    }\n\n    fileNames.forEach((fileName) => {\n        let sourceFile: ts.Node;\n        let sourceFileName: string;\n\n        const fileNameAlternatives = [];\n\n        if (\n            !fileName.endsWith(\".ts\") &&\n            !fileName.endsWith(\".js\") &&\n            !fileName.endsWith(\".mjs\")\n        ) {\n            fileNameAlternatives.push(`${fileName}.ts`);\n            fileNameAlternatives.push(`${fileName}/index.ts`);\n\n        } else if (fileName.endsWith(\".js\")) {\n            // Handle .js extensions by also trying .ts (ESM imports often use .js extension)\n            fileNameAlternatives.push(fileName);\n            fileNameAlternatives.push(fileName.replace(/\\.js$/, \".ts\"));\n\n        } else {\n            fileNameAlternatives.push(fileName);\n        }\n\n        for (let i = 0; i < fileNameAlternatives.length; i++) {\n            try {\n                sourceFileName = path.resolve(fileNameAlternatives[i]);\n\n                if (parsedFiles[sourceFileName]) {\n                    break;\n                }\n\n                sourceFile = ts.createSourceFile(\n                    sourceFileName,\n                    readFileSync(sourceFileName).toString(),\n                    ts.ScriptTarget.Latest,\n                    true\n                );\n\n                parsedFiles[sourceFileName] = true;\n\n                break;\n            } catch (e) {\n                // console.log(`${fileNameAlternatives[i]} => ${e.message}`);\n            }\n        }\n\n        if (sourceFile) {\n            inspectNode(sourceFile, context, decoratorName);\n        }\n    });\n\n    return context.getStructures();\n}\n\n/**\n * TypeScript 4.8+ has introduced a change on how to access decorators.\n * - https://github.com/microsoft/TypeScript/pull/49089\n * - https://devblogs.microsoft.com/typescript/announcing-typescript-4-8/#decorators-are-placed-on-modifiers-on-typescripts-syntax-trees\n */\nexport function getDecorators(node: ts.Node | null | undefined,): undefined | ts.Decorator[] {\n    if (node == undefined) { return undefined; }\n\n    // TypeScript 4.7 and below\n    // @ts-ignore\n    if (node.decorators) { return node.decorators; }\n\n    // TypeScript 4.8 and above\n    // @ts-ignore\n    if (ts.canHaveDecorators && ts.canHaveDecorators(node)) {\n        // @ts-ignore\n        const decorators = ts.getDecorators(node);\n        return decorators ? Array.from(decorators) : undefined;\n    }\n\n    // @ts-ignore\n    return node.modifiers?.filter(ts.isDecorator);\n}\n","import {\n    Class,\n    Property,\n    File,\n    getCommentHeader,\n    Interface,\n    Enum,\n} from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\nimport { Context } from \"../types.js\";\n\nexport const name = \"Unity/C#\";\n\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"string\",\n    \"number\": \"float\",\n    \"boolean\": \"bool\",\n    \"int8\": \"sbyte\",\n    \"uint8\": \"byte\",\n    \"int16\": \"short\",\n    \"uint16\": \"ushort\",\n    \"int32\": \"int\",\n    \"uint32\": \"uint\",\n    \"int64\": \"long\",\n    \"uint64\": \"ulong\",\n    \"float32\": \"float\",\n    \"float64\": \"double\",\n}\n\nconst COMMON_IMPORTS = `using Colyseus.Schema;\n#if UNITY_5_3_OR_NEWER\nusing UnityEngine.Scripting;\n#endif`;\n\n/**\n * C# Code Generator\n */\nconst capitalize = (s: string) => {\n    if (typeof s !== 'string') return ''\n    return s.charAt(0).toUpperCase() + s.slice(1);\n}\n\n/**\n * Generate individual files for each class/interface/enum\n */\nexport function generate(context: Context, options: GenerateOptions): File[] {\n    // enrich typeMaps with enums\n    context.enums.forEach((structure) => {\n        typeMaps[structure.name] = structure.name;\n    });\n    return [\n        ...context.classes.map(structure => ({\n            name: `${structure.name}.cs`,\n            content: generateClass(structure, options.namespace)\n        })),\n        ...context.interfaces.map(structure => ({\n            name: `${structure.name}.cs`,\n            content: generateInterface(structure, options.namespace),\n        })),\n        ...context.enums.filter(structure => structure.name !== 'OPERATION').map((structure) => ({\n            name: `${structure.name}.cs`,\n            content: generateEnum(structure, options.namespace),\n        })),\n    ];\n}\n\n/**\n * Generate a single bundled file containing all classes, interfaces, and enums\n */\nexport function renderBundle(context: Context, options: GenerateOptions): File {\n    const fileName = options.namespace ? `${options.namespace}.cs` : \"Schema.cs\";\n    const indent = options.namespace ? \"\\t\" : \"\";\n\n    // enrich typeMaps with enums\n    context.enums.forEach((structure) => {\n        typeMaps[structure.name] = structure.name;\n    });\n\n    // Collect all bodies\n    const classBodies = context.classes.map(klass => generateClassBody(klass, indent));\n    const interfaceBodies = context.interfaces.map(iface => generateInterfaceBody(iface, indent));\n    const enumBodies = context.enums\n        .filter(structure => structure.name !== 'OPERATION')\n        .map(e => generateEnumBody(e, indent));\n\n    const allBodies = [...classBodies, ...interfaceBodies, ...enumBodies].join(\"\\n\\n\");\n\n    const content = `${getCommentHeader()}\n\n${COMMON_IMPORTS}\n${options.namespace ? `\\nnamespace ${options.namespace} {\\n` : \"\"}\n${allBodies}\n${options.namespace ? \"}\" : \"\"}`;\n\n    return { name: fileName, content };\n}\n\n/**\n * Generate just the class body (without imports/namespace) for bundling\n */\nfunction generateClassBody(klass: Class, indent: string = \"\"): string {\n    return `${indent}public partial class ${klass.name} : ${klass.extends} {\n#if UNITY_5_3_OR_NEWER\n[Preserve]\n#endif\npublic ${klass.name}() { }\n${klass.properties.map((prop) => generateProperty(prop, indent)).join(\"\\n\\n\")}\n${indent}}`;\n}\n\n/**\n * Generate a complete class file with imports/namespace (for individual file mode)\n */\nfunction generateClass(klass: Class, namespace: string) {\n    const indent = (namespace) ? \"\\t\" : \"\";\n    return `${getCommentHeader()}\n\n${COMMON_IMPORTS}\n${namespace ? `\\nnamespace ${namespace} {` : \"\"}\n${generateClassBody(klass, indent)}\n${namespace ? \"}\" : \"\"}\n`;\n}\n\n/**\n * Generate just the enum body (without imports/namespace) for bundling\n */\nfunction generateEnumBody(_enum: Enum, indent: string = \"\"): string {\n    return `${indent}public struct ${_enum.name} {\n\n${_enum.properties\n    .map((prop) => {\n        let dataType: string = \"int\";\n        let value: any;\n\n        if(prop.type) {\n            if(isNaN(Number(prop.type))) {\n                value = `\"${prop.type}\"`;\n                dataType = \"string\";\n            } else {\n                value = Number(prop.type);\n                dataType = Number.isInteger(value)? 'int': 'float';\n            }\n        } else {\n            value = _enum.properties.indexOf(prop);\n        }\n        return `${indent}\\tpublic const ${dataType} ${prop.name} = ${value};`;\n    })\n        .join(\"\\n\")}\n${indent}}`;\n}\n\n/**\n * Generate a complete enum file with imports/namespace (for individual file mode)\n */\nfunction generateEnum(_enum: Enum, namespace: string) {\n    const indent = namespace ? \"\\t\" : \"\";\n    return `${getCommentHeader()}\n${namespace ? `\\nnamespace ${namespace} {` : \"\"}\n${generateEnumBody(_enum, indent)}\n${namespace ? \"}\" : \"\"}`\n}\n\nfunction generateProperty(prop: Property, indent: string = \"\") {\n    let typeArgs = `\"${prop.type}\"`;\n    let property = \"public\";\n    let langType: string;\n    let initializer = \"\";\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        langType = getType(prop);\n        typeArgs += `, typeof(${langType})`;\n\n        if (!isUpcaseFirst) {\n            typeArgs += `, \"${prop.childType}\"`;\n        }\n\n        initializer = `null`;\n\n    } else {\n        langType = getType(prop);\n        initializer = `default(${langType})`;\n    }\n\n    property += ` ${langType} ${prop.name}`;\n\n    let ret = (prop.deprecated) ? `\\t\\t[System.Obsolete(\"field '${prop.name}' is deprecated.\", true)]\\n` : '';\n\n    return ret + `\\t${indent}[Type(${prop.index}, ${typeArgs})]\n\\t${indent}${property} = ${initializer};`;\n}\n\n/**\n * Generate just the interface body (without imports/namespace) for bundling\n */\nfunction generateInterfaceBody(struct: Interface, indent: string = \"\"): string {\n    return `${indent}public class ${struct.name} {\n${struct.properties.map(prop => `\\t${indent}public ${getType(prop)} ${prop.name};`).join(\"\\n\")}\n${indent}}`;\n}\n\n/**\n * Generate a complete interface file with imports/namespace (for individual file mode)\n */\nfunction generateInterface(struct: Interface, namespace: string) {\n    const indent = (namespace) ? \"\\t\" : \"\";\n    return `${getCommentHeader()}\n\nusing Colyseus.Schema;\n${namespace ? `\\nnamespace ${namespace} {` : \"\"}\n${generateInterfaceBody(struct, indent)}\n${namespace ? \"}\" : \"\"}\n`;\n}\n\nfunction getChildType(prop: Property) {\n    return typeMaps[prop.childType];\n}\n\nfunction getType(prop: Property) {\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n        let type: string;\n\n        if(prop.type === \"ref\") {\n            type = (isUpcaseFirst)\n                ? prop.childType\n                : getChildType(prop);\n        } else {\n            const containerClass = capitalize(prop.type);\n            type = (isUpcaseFirst)\n                ? `${containerClass}Schema<${prop.childType}>`\n                : `${containerClass}Schema<${getChildType(prop)}>`;\n        }\n        return type;\n\n    } else {\n        return (prop.type === \"array\")\n            ? `${typeMaps[prop.childType] || prop.childType}[]`\n            : typeMaps[prop.type];\n    }\n}\n","import { Class, Property, File, getCommentHeader, getInheritanceTree, Context } from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\n\nexport const name = \"C++\";\n\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"string\",\n    \"number\": \"varint_t\",\n    \"boolean\": \"bool\",\n    \"int8\": \"int8_t\",\n    \"uint8\": \"uint8_t\",\n    \"int16\": \"int16_t\",\n    \"uint16\": \"uint16_t\",\n    \"int32\": \"int32_t\",\n    \"uint32\": \"uint32_t\",\n    \"int64\": \"int64_t\",\n    \"uint64\": \"uint64_t\",\n    \"float32\": \"float32_t\",\n    \"float64\": \"float64_t\",\n}\n\nconst typeInitializer: { [key: string]: string } = {\n    \"string\": '\"\"',\n    \"number\": \"0\",\n    \"boolean\": \"false\",\n    \"int8\": \"0\",\n    \"uint8\": \"0\",\n    \"int16\": \"0\",\n    \"uint16\": \"0\",\n    \"int32\": \"0\",\n    \"uint32\": \"0\",\n    \"int64\": \"0\",\n    \"uint64\": \"0\",\n    \"float32\": \"0\",\n    \"float64\": \"0\",\n}\n\nconst COMMON_INCLUDES = `#include \"schema.h\"\n#include <typeinfo>\n#include <typeindex>\n\nusing namespace colyseus::schema;`;\n\n/**\n * C++ Code Generator\n */\n\nconst capitalize = (s: string) => {\n    if (typeof s !== 'string') return ''\n    return s.charAt(0).toUpperCase() + s.slice(1);\n}\nconst distinct = (value: string, index: number, self: string[]) =>\n    self.indexOf(value) === index;\n\n/**\n * Generate individual files for each class\n */\nexport function generate (context: Context, options: GenerateOptions): File[] {\n    return context.classes.map(klass => ({\n        name: klass.name + \".hpp\",\n        content: generateClass(klass, options.namespace, context.classes)\n    }));\n}\n\n/**\n * Generate a single bundled header file containing all classes\n */\nexport function renderBundle(context: Context, options: GenerateOptions): File {\n    const fileName = options.namespace ? `${options.namespace}.hpp` : \"schema.hpp\";\n    const guardName = `__SCHEMA_CODEGEN_${(options.namespace || \"SCHEMA\").toUpperCase()}_H__`;\n\n    const classBodies = context.classes.map(klass => generateClassBody(klass, context.classes, options.namespace));\n\n    const content = `${getCommentHeader()}\n#ifndef ${guardName}\n#define ${guardName} 1\n\n${COMMON_INCLUDES}\n\n${options.namespace ? `namespace ${options.namespace} {\\n` : \"\"}\n${classBodies.join(\"\\n\\n\")}\n${options.namespace ? \"}\" : \"\"}\n\n#endif\n`;\n\n    return { name: fileName, content };\n}\n\n/**\n * Generate just the class body (without includes/guards) for bundling\n */\nfunction generateClassBody(klass: Class, allClasses: Class[], namespace: string): string {\n    const propertiesPerType: {[type: string]: Property[]} = {};\n    const allRefs: Property[] = [];\n    klass.properties.forEach(property => {\n        let type = property.type;\n\n        if (!propertiesPerType[type]) {\n            propertiesPerType[type] = [];\n        }\n\n        propertiesPerType[type].push(property);\n\n        // keep all refs list\n        if ((type === \"ref\" || type === \"array\" || type === \"map\")) {\n            allRefs.push(property);\n        }\n    });\n\n    const allProperties = getAllProperties(klass, allClasses);\n    const createInstanceMethod = (allRefs.length === 0) ? \"\" :\n    `\\tinline Schema* createInstance(std::type_index type) {\n\\t\\t${generateFieldIfElseChain(allRefs,\n    (property) => `type == typeid(${property.childType})`,\n    (property) => `return new ${property.childType}();`,\n    (property) => typeMaps[property.childType] === undefined)}\n\\t\\treturn ${klass.extends}::createInstance(type);\n\\t}`;\n\n    return `class ${klass.name} : public ${klass.extends} {\npublic:\n${klass.properties.map(prop => generateProperty(prop)).join(\"\\n\")}\n\n\\t${klass.name}() {\n\\t\\tthis->_indexes = ${generateAllIndexes(allProperties)};\n\\t\\tthis->_types = ${generateAllTypes(allProperties)};\n\\t\\tthis->_childPrimitiveTypes = ${generateAllChildPrimitiveTypes(allProperties)};\n\\t\\tthis->_childSchemaTypes = ${generateAllChildSchemaTypes(allProperties)};\n\\t}\n\n\\tvirtual ~${klass.name}() {\n\\t\\t${generateDestructors(allProperties).join(\"\\n\\t\\t\")}\n\\t}\n\nprotected:\n${Object.keys(propertiesPerType).map(type =>\n    generateGettersAndSetters(klass, type, propertiesPerType[type])).\n    join(\"\\n\")}\n\n${createInstanceMethod}\n};`;\n}\n\n/**\n * Generate a complete class file with includes/guards (for individual file mode)\n */\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\n    const allRefs: Property[] = [];\n    klass.properties.forEach(property => {\n        let type = property.type;\n        // keep all refs list\n        if ((type === \"ref\" || type === \"array\" || type === \"map\")) {\n            allRefs.push(property);\n        }\n    });\n\n    const localIncludes = allRefs.\n        filter(ref => ref.childType && typeMaps[ref.childType] === undefined).\n        map(ref => ref.childType).\n        concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).\n        filter(distinct).\n        map(childType => `#include \"${childType}.hpp\"`).\n        join(\"\\n\");\n\n    return `${getCommentHeader()}\n#ifndef __SCHEMA_CODEGEN_${klass.name.toUpperCase()}_H__\n#define __SCHEMA_CODEGEN_${klass.name.toUpperCase()}_H__ 1\n\n${COMMON_INCLUDES}\n${localIncludes}\n\n${namespace ? `namespace ${namespace} {` : \"\"}\n${generateClassBody(klass, allClasses, namespace)}\n${namespace ? \"}\" : \"\"}\n\n#endif\n`;\n}\n\nfunction generateProperty(prop: Property) {\n    let property = \"\";\n    let langType: string;\n    let initializer = \"\";\n    let isPropPointer = \"\";\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        if(prop.type === \"ref\") {\n            langType = `${prop.childType}`;\n            initializer = `new ${prop.childType}()`;\n\n        } else if(prop.type === \"array\") {\n            langType = (isUpcaseFirst)\n                ? `ArraySchema<${prop.childType}*>`\n                : `ArraySchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n\n        } else if(prop.type === \"map\") {\n            langType = (isUpcaseFirst)\n                ? `MapSchema<${prop.childType}*>`\n                : `MapSchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n        }\n        isPropPointer = \"*\";\n\n    } else {\n        langType = typeMaps[prop.type];\n        initializer = typeInitializer[prop.type];\n    }\n\n    property += ` ${langType} ${isPropPointer}${prop.name}`;\n\n    return `\\t${property} = ${initializer};`\n}\n\nfunction generateGettersAndSetters(klass: Class, type: string, properties: Property[]) {\n    let langType = typeMaps[type];\n    let typeCast = \"\";\n\n    const getMethodName = `get${capitalize(type)}`;\n    const setMethodName = `set${capitalize(type)}`;\n\n    if (type === \"ref\") {\n        langType = \"Schema*\";\n\n    } else if (type === \"array\") {\n        langType = `ArraySchema<char*> *`;\n        typeCast = `(ArraySchema<char*> *)`;\n\n    } else if (type === \"map\") {\n        langType = `MapSchema<char*> *`;\n        typeCast = `(MapSchema<char*> *)`;\n    }\n\n    return `\\tinline ${langType} ${getMethodName}(const string &field)\n\\t{\n\\t\\t${generateFieldIfElseChain(properties,\n    (property) => `field == \"${property.name}\"`,\n    (property) => `return ${typeCast}this->${property.name};`)}\n\\t\\treturn ${klass.extends}::${getMethodName}(field);\n\\t}\n\n\\tinline void ${setMethodName}(const string &field, ${langType} value)\n\\t{\n\\t\\t${generateFieldIfElseChain(properties,\n    (property) => `field == \"${property.name}\"`,\n    (property) => {\n        const isSchemaType = (typeMaps[property.childType] === undefined)\n\n        if (type === \"ref\") {\n            langType = `${property.childType}*`;\n            typeCast = (isSchemaType)\n                ? `(${property.childType}*)`\n                : `/* bug? */`;\n\n        } else if (type === \"array\") {\n            typeCast = (isSchemaType)\n                ? `(ArraySchema<${property.childType}*> *)`\n                : `(ArraySchema<${typeMaps[property.childType]}> *)`;\n\n        } else if (type === \"map\") {\n            typeCast = (isSchemaType)\n                ? `(MapSchema<${property.childType}*> *)`\n                : `(MapSchema<${typeMaps[property.childType]}> *)`;\n        }\n\n        return `this->${property.name} = ${typeCast}value;\\n\\t\\t\\treturn;`\n    })}\n\\t\\treturn ${klass.extends}::${setMethodName}(field, value);\n\\t}`;\n}\n\nfunction generateFieldIfElseChain(\n    properties: Property[],\n    ifCallback: (property: Property) => string,\n    callback: (property: Property) => string,\n    filter: (property: Property) => boolean = (_) => true,\n) {\n    let chain = \"\";\n\n    const uniqueChecks: string[] = [];\n    properties.filter(filter).forEach((property, i) => {\n        const check = ifCallback(property);\n        if (uniqueChecks.indexOf(check) === -1) {\n            uniqueChecks.push(check);\n\n        } else {\n            return;\n        }\n\n        if (i === 0) { chain += \"if \" } else { chain += \" else if \" }\n        chain += `(${check})\n\\t\\t{\n\\t\\t\\t${callback(property)}\\n\n\\t\\t}`\n    });\n\n    return chain;\n}\n\nfunction generateAllIndexes(properties: Property[]) {\n    return `{${properties.map((property, i) => `{${i}, \"${property.name}\"}`).join(\", \")}}`\n\n}\n\nfunction generateAllTypes(properties: Property[]) {\n    return `{${properties.map((property, i) => `{${i}, \"${property.type}\"}`).join(\", \")}}`\n}\n\nfunction generateAllChildSchemaTypes(properties: Property[]) {\n    return `{${properties.map((property, i) => {\n        if (property.childType && typeMaps[property.childType] === undefined) {\n            return `{${i}, typeid(${property.childType})}`\n        } else {\n            return null;\n        }\n    }).filter(r => r !== null).join(\", \")}}`\n}\n\nfunction generateAllChildPrimitiveTypes(properties: Property[]) {\n    return `{${properties.map((property, i) => {\n        if (typeMaps[property.childType] !== undefined) {\n            return `{${i}, \"${property.childType}\"}`\n        } else {\n            return null;\n        }\n    }).filter(r => r !== null).join(\", \")}}`\n}\n\nfunction generateDestructors(properties: Property[]) {\n    return properties.map((property, i) => {\n        if (property.childType) {\n            return `delete this->${property.name};`;\n        } else {\n            return null;\n        }\n    }).filter(r => r !== null);\n}\n\nfunction getAllProperties (klass: Class, allClasses: Class[]) {\n    let properties: Property[] = [];\n\n    getInheritanceTree(klass, allClasses).reverse().forEach((klass) => {\n        properties = properties.concat(klass.properties);\n    });\n\n    return properties;\n}","import { Class, Property, File, getCommentHeader, Context } from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\n\nexport const name = \"Haxe\";\n\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"String\",\n    \"number\": \"Dynamic\",\n    \"boolean\": \"Bool\",\n    \"int8\": \"Int\",\n    \"uint8\": \"UInt\",\n    \"int16\": \"Int\",\n    \"uint16\": \"UInt\",\n    \"int32\": \"Int\",\n    \"uint32\": \"UInt\",\n    \"int64\": \"Int\",\n    \"uint64\": \"UInt\",\n    \"float32\": \"Float\",\n    \"float64\": \"Float\",\n}\n\nconst typeInitializer: { [key: string]: string } = {\n    \"string\": '\"\"',\n    \"number\": \"0\",\n    \"boolean\": \"false\",\n    \"int8\": \"0\",\n    \"uint8\": \"0\",\n    \"int16\": \"0\",\n    \"uint16\": \"0\",\n    \"int32\": \"0\",\n    \"uint32\": \"0\",\n    \"int64\": \"0\",\n    \"uint64\": \"0\",\n    \"float32\": \"0\",\n    \"float64\": \"0\",\n}\n\nconst COMMON_IMPORTS = `import io.colyseus.serializer.schema.Schema;\nimport io.colyseus.serializer.schema.types.*;`;\n\n/**\n * Generate individual files for each class\n */\nexport function generate (context: Context, options: GenerateOptions): File[] {\n    return context.classes.map(klass => ({\n        name: klass.name + \".hx\",\n        content: generateClass(klass, options.namespace, context.classes)\n    }));\n}\n\n/**\n * Generate a single bundled file containing all classes\n */\nexport function renderBundle(context: Context, options: GenerateOptions): File {\n    const fileName = options.namespace ? `${options.namespace}.hx` : \"Schema.hx\";\n\n    const classBodies = context.classes.map(klass => generateClassBody(klass));\n\n    const content = `${getCommentHeader()}\n\n${options.namespace ? `package ${options.namespace};` : \"\"}\n${COMMON_IMPORTS}\n\n${classBodies.join(\"\\n\\n\")}\n`;\n\n    return { name: fileName, content };\n}\n\nfunction getInheritanceTree(klass: Class, allClasses: Class[], includeSelf: boolean = true) {\n    let currentClass = klass;\n    let inheritanceTree: Class[] = [];\n\n    if (includeSelf) {\n        inheritanceTree.push(currentClass);\n    }\n\n    while (currentClass.extends !== \"Schema\") {\n        currentClass = allClasses.find(klass => klass.name == currentClass.extends);\n        inheritanceTree.push(currentClass);\n    }\n\n    return inheritanceTree;\n}\n\n/**\n * Generate just the class body (without package/imports) for bundling\n */\nfunction generateClassBody(klass: Class): string {\n    return `class ${klass.name} extends ${klass.extends} {\n${klass.properties.map(prop => generateProperty(prop)).join(\"\\n\")}\n}`;\n}\n\n/**\n * Generate a complete class file with package/imports (for individual file mode)\n */\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\n    return `${getCommentHeader()}\n\n${namespace ? `package ${namespace};` : \"\"}\n${COMMON_IMPORTS}\n\n${generateClassBody(klass)}\n`;\n}\n\nfunction generateProperty(prop: Property) {\n    let langType: string;\n    let initializer = \"\";\n    let typeArgs = `\"${prop.type}\"`;\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        if (isUpcaseFirst) {\n            typeArgs += `, ${prop.childType}`;\n\n        } else {\n            typeArgs += `, \"${prop.childType}\"`;\n        }\n\n        if(prop.type === \"ref\") {\n            langType = `${prop.childType}`;\n            initializer = `new ${prop.childType}()`;\n\n        } else if(prop.type === \"array\") {\n            langType = (isUpcaseFirst)\n                ? `ArraySchema<${prop.childType}>`\n                : `ArraySchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n\n        } else if(prop.type === \"map\") {\n            langType = (isUpcaseFirst)\n                ? `MapSchema<${prop.childType}>`\n                : `MapSchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n        }\n\n    } else {\n        langType = typeMaps[prop.type];\n        initializer = typeInitializer[prop.type];\n    }\n\n    // TODO: remove initializer. The callbacks at the Haxe decoder side have a\n    // \"FIXME\" comment about this on Decoder.hx\n\n    return `\\t@:type(${typeArgs})\\n\\tpublic var ${prop.name}: ${langType} = ${initializer};\\n`\n    // return `\\t@:type(${typeArgs})\\n\\tpublic var ${prop.name}: ${langType};\\n`\n}\n","import { Class, Property, File, getCommentHeader, getInheritanceTree, Context, Interface } from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\n\nexport const name = \"TypeScript\";\n\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"string\",\n    \"number\": \"number\",\n    \"boolean\": \"boolean\",\n    \"int8\": \"number\",\n    \"uint8\": \"number\",\n    \"int16\": \"number\",\n    \"uint16\": \"number\",\n    \"int32\": \"number\",\n    \"uint32\": \"number\",\n    \"int64\": \"number\",\n    \"uint64\": \"number\",\n    \"float32\": \"number\",\n    \"float64\": \"number\",\n}\n\nconst COMMON_IMPORTS = `import { Schema, type, ArraySchema, MapSchema, SetSchema, DataChange } from '@colyseus/schema';`;\n\nconst distinct = (value: string, index: number, self: string[]) =>\n    self.indexOf(value) === index;\n\n/**\n * Generate individual files for each class/interface\n */\nexport function generate (context: Context, options: GenerateOptions): File[] {\n    return [\n        ...context.classes.map(structure => ({\n            name: structure.name + \".ts\",\n            content: generateClass(structure, options.namespace, context.classes)\n        })),\n        ...context.interfaces.map(structure => ({\n            name: structure.name + \".ts\",\n            content: generateInterface(structure, options.namespace, context.classes),\n        }))\n    ];\n}\n\n/**\n * Generate a single bundled file containing all classes and interfaces\n */\nexport function renderBundle(context: Context, options: GenerateOptions): File {\n    const fileName = options.namespace ? `${options.namespace}.ts` : \"schema.ts\";\n\n    // Collect all class bodies\n    const classBodies = context.classes.map(klass => generateClassBody(klass));\n\n    // Collect all interface bodies\n    const interfaceBodies = context.interfaces.map(iface => generateInterfaceBody(iface));\n\n    const content = `${getCommentHeader()}\n\n${COMMON_IMPORTS}\n\n${classBodies.join(\"\\n\\n\")}\n${interfaceBodies.length > 0 ? \"\\n\" + interfaceBodies.join(\"\\n\\n\") : \"\"}`;\n\n    return { name: fileName, content };\n}\n\n/**\n * Generate just the class body (without imports) for bundling\n */\nfunction generateClassBody(klass: Class): string {\n    return `export class ${klass.name} extends ${klass.extends} {\n${klass.properties.map(prop => `    ${generateProperty(prop)}`).join(\"\\n\")}\n}`;\n}\n\n/**\n * Generate just the interface body (without imports) for bundling\n */\nfunction generateInterfaceBody(iface: Interface): string {\n    return `export interface ${iface.name} {\n${iface.properties.map(prop => `    ${prop.name}: ${prop.type};`).join(\"\\n\")}\n}`;\n}\n\n/**\n * Generate a complete class file with imports (for individual file mode)\n */\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\n    const allRefs: Property[] = [];\n    klass.properties.forEach(property => {\n        let type = property.type;\n\n        // keep all refs list\n        if ((type === \"ref\" || type === \"array\" || type === \"map\" || type === \"set\")) {\n            allRefs.push(property);\n        }\n    });\n\n    const localImports = allRefs.\n        filter(ref => ref.childType && typeMaps[ref.childType] === undefined).\n        map(ref => ref.childType).\n        concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).\n        filter(distinct).\n        map(childType => `import { ${childType} } from './${childType}'`).\n        join(\"\\n\");\n\n    return `${getCommentHeader()}\n\n${COMMON_IMPORTS}\n${localImports}\n\n${generateClassBody(klass)}\n`;\n}\n\nfunction generateProperty(prop: Property) {\n    let langType: string;\n    let initializer = \"\";\n    let typeArgs: string;\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        if (isUpcaseFirst) {\n            typeArgs += `, ${prop.childType}`;\n\n        } else {\n            typeArgs += `, \"${prop.childType}\"`;\n        }\n\n        if(prop.type === \"ref\") {\n            langType = `${prop.childType}`;\n            initializer = `new ${prop.childType}()`;\n            typeArgs = `${prop.childType}`;\n\n        } else if(prop.type === \"array\") {\n            langType = (isUpcaseFirst)\n                ? `ArraySchema<${prop.childType}>`\n                : `ArraySchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n            typeArgs = (isUpcaseFirst)\n                ? `[ ${prop.childType} ]`\n                : `[ \"${prop.childType}\" ]`;\n\n        } else if(prop.type === \"map\") {\n            langType = (isUpcaseFirst)\n                ? `MapSchema<${prop.childType}>`\n                : `MapSchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n            typeArgs = (isUpcaseFirst)\n                ? `{ map: ${prop.childType} }`\n                : `{ map: \"${prop.childType}\" }`;\n        } else if (prop.type === \"set\") {\n            langType = (isUpcaseFirst)\n                ? `SetSchema<${prop.childType}>`\n                : `SetSchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n            typeArgs = (isUpcaseFirst)\n                ? `{ set: ${prop.childType} }`\n                : `{ set: \"${prop.childType}\" }`;\n        }\n\n    } else {\n        langType = typeMaps[prop.type];\n        typeArgs = `\"${prop.type}\"`;\n    }\n\n    // TS1263: \"Declarations with initializers cannot also have definite assignment assertions\"\n    const definiteAssertion = initializer ? \"\" : \"!\";\n\n    return `@type(${typeArgs}) public ${prop.name}${definiteAssertion}: ${langType}${(initializer) ? ` = ${initializer}` : \"\"};`\n}\n\n\n/**\n * Generate a complete interface file with header (for individual file mode)\n */\nfunction generateInterface(structure: Interface, namespace: string, allClasses: Class[]) {\n    return `${getCommentHeader()}\n\n${generateInterfaceBody(structure)}\n`;\n}\n","import { Class, Property, File, getCommentHeader, getInheritanceTree, Context } from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\n\nexport const name = \"JavaScript\";\n\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"string\",\n    \"number\": \"number\",\n    \"boolean\": \"boolean\",\n    \"int8\": \"number\",\n    \"uint8\": \"number\",\n    \"int16\": \"number\",\n    \"uint16\": \"number\",\n    \"int32\": \"number\",\n    \"uint32\": \"number\",\n    \"int64\": \"number\",\n    \"uint64\": \"number\",\n    \"float32\": \"number\",\n    \"float64\": \"number\",\n}\n\nconst COMMON_IMPORTS = `const schema = require(\"@colyseus/schema\");\nconst Schema = schema.Schema;\nconst type = schema.type;`;\n\nconst distinct = (value: string, index: number, self: string[]) =>\n    self.indexOf(value) === index;\n\n/**\n * Generate individual files for each class\n */\nexport function generate (context: Context, options: GenerateOptions): File[] {\n    return context.classes.map(klass => ({\n        name: klass.name + \".js\",\n        content: generateClass(klass, options.namespace, context.classes)\n    }));\n}\n\n/**\n * Generate a single bundled file containing all classes\n */\nexport function renderBundle(context: Context, options: GenerateOptions): File {\n    const fileName = options.namespace ? `${options.namespace}.js` : \"schema.js\";\n\n    const classBodies = context.classes.map(klass => generateClassBody(klass));\n    const classExports = context.classes.map(klass => `    ${klass.name},`).join(\"\\n\");\n\n    const content = `${getCommentHeader()}\n\n${COMMON_IMPORTS}\n\n${classBodies.join(\"\\n\\n\")}\n\nmodule.exports = {\n${classExports}\n};\n`;\n\n    return { name: fileName, content };\n}\n\n/**\n * Generate just the class body (without imports) for bundling\n */\nfunction generateClassBody(klass: Class): string {\n    return `class ${klass.name} extends ${klass.extends} {\n    constructor () {\n        super();\n${klass.properties.\n    filter(prop => prop.childType !== undefined).\n    map(prop => \"        \" + generatePropertyInitializer(prop)).join(\"\\n\")}\n    }\n}\n${klass.properties.map(prop => generatePropertyDeclaration(klass.name, prop)).join(\"\\n\")}`;\n}\n\n/**\n * Generate a complete class file with imports (for individual file mode)\n */\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\n    const allRefs: Property[] = [];\n    klass.properties.forEach(property => {\n        let type = property.type;\n\n        // keep all refs list\n        if ((type === \"ref\" || type === \"array\" || type === \"map\")) {\n            allRefs.push(property);\n        }\n    });\n\n    const localImports = allRefs.\n        filter(ref => ref.childType && typeMaps[ref.childType] === undefined).\n        map(ref => ref.childType).\n        concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).\n        filter(distinct).\n        map(childType => `const ${childType} = require(\"./${childType}\");`).\n        join(\"\\n\");\n\n    return `${getCommentHeader()}\n\n${COMMON_IMPORTS}\n${localImports}\n\n${generateClassBody(klass)}\n\nexport default ${klass.name};\n`;\n}\n\nfunction generatePropertyDeclaration(className: string, prop: Property) {\n    let typeArgs: string;\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        if (isUpcaseFirst) {\n            typeArgs += `, ${prop.childType}`;\n\n        } else {\n            typeArgs += `, \"${prop.childType}\"`;\n        }\n\n        if(prop.type === \"ref\") {\n            typeArgs = `${prop.childType}`;\n\n        } else if(prop.type === \"array\") {\n            typeArgs = (isUpcaseFirst)\n                ? `[ ${prop.childType} ]`\n                : `[ \"${prop.childType}\" ]`;\n\n        } else if(prop.type === \"map\") {\n            typeArgs = (isUpcaseFirst)\n                ? `{ map: ${prop.childType} }`\n                : `{ map: \"${prop.childType}\" }`;\n        }\n\n    } else {\n        typeArgs = `\"${prop.type}\"`;\n    }\n\n    return `type(${typeArgs})(${className}.prototype, \"${prop.name}\");`;\n}\n\nfunction generatePropertyInitializer(prop: Property) {\n    let initializer = \"\";\n\n    if(prop.type === \"ref\") {\n        initializer = `new ${prop.childType}()`;\n\n    } else if(prop.type === \"array\") {\n        initializer = `new schema.ArraySchema()`;\n\n    } else if(prop.type === \"map\") {\n        initializer = `new schema.MapSchema()`;\n    }\n\n    return `this.${prop.name} = ${initializer}`;\n}\n","import { Class, Property, File, getCommentHeader, Context } from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\n\nexport const name = \"Java\";\n\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"String\",\n    \"number\": \"float\",\n    \"boolean\": \"boolean\",\n    \"int8\": \"byte\",\n    \"uint8\": \"short\",\n    \"int16\": \"short\",\n    \"uint16\": \"int\",\n    \"int32\": \"int\",\n    \"uint32\": \"long\",\n    \"int64\": \"long\",\n    \"uint64\": \"long\",\n    \"float32\": \"float\",\n    \"float64\": \"double\",\n}\n\nconst typeInitializer: { [key: string]: string } = {\n    \"string\": '\"\"',\n    \"number\": \"0\",\n    \"boolean\": \"false\",\n    \"int8\": \"0\",\n    \"uint8\": \"0\",\n    \"int16\": \"0\",\n    \"uint16\": \"0\",\n    \"int32\": \"0\",\n    \"uint32\": \"0\",\n    \"int64\": \"0\",\n    \"uint64\": \"0\",\n    \"float32\": \"0\",\n    \"float64\": \"0\",\n}\n\nconst COMMON_IMPORTS = `import io.colyseus.serializer.schema.Schema;\nimport io.colyseus.serializer.schema.annotations.SchemaClass;\nimport io.colyseus.serializer.schema.annotations.SchemaField;`;\n\n/**\n * Java Code Generator\n */\n\n/**\n * Generate individual files for each class\n */\nexport function generate (context: Context, options: GenerateOptions): File[] {\n    return context.classes.map(klass => ({\n        name: klass.name + \".java\",\n        content: generateClass(klass, options.namespace)\n    }));\n}\n\n/**\n * Generate a single bundled file containing all classes\n * Note: Java typically requires one public class per file, so bundled mode\n * generates all classes in a single file with package-private visibility\n */\nexport function renderBundle(context: Context, options: GenerateOptions): File {\n    const fileName = options.namespace ? `Schema.java` : \"Schema.java\";\n\n    const classBodies = context.classes.map(klass => generateClassBody(klass));\n\n    const content = `${getCommentHeader()}\n${options.namespace ? `\\npackage ${options.namespace};` : \"\"}\n\n${COMMON_IMPORTS}\n\n${classBodies.join(\"\\n\\n\")}\n`;\n\n    return { name: fileName, content };\n}\n\n/**\n * Generate just the class body (without package/imports) for bundling\n */\nfunction generateClassBody(klass: Class): string {\n    return `@SchemaClass\nclass ${klass.name} extends ${klass.extends} {\n${klass.properties.map(prop => generateProperty(prop, \"\")).join(\"\\n\\n\")}\n}`;\n}\n\n/**\n * Generate a complete class file with package/imports (for individual file mode)\n */\nfunction generateClass(klass: Class, namespace: string) {\n    const indent = (namespace) ? \"\\t\" : \"\";\n    return `${getCommentHeader()}\n${namespace ? `\\npackage ${namespace};` : \"\"}\n\n${COMMON_IMPORTS}\n\n@SchemaClass\n${indent}public class ${klass.name} extends ${klass.extends} {\n${klass.properties.map(prop => generateProperty(prop, indent)).join(\"\\n\\n\")}\n${indent}}\n${namespace ? \"}\" : \"\"}\n`;\n}\n\nfunction generateProperty(prop: Property, indent: string = \"\") {\n    let typeArgs = `${prop.index}/${prop.type}`;\n    let property = \"public\";\n    let langType: string;\n    let ctorArgs: string = \"\";\n    let initializer = \"\";\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        if (prop.type !== \"ref\" && isUpcaseFirst) {\n            ctorArgs = `${prop.childType}.class`;\n        }\n\n        if(prop.type === \"ref\") {\n            langType = (isUpcaseFirst)\n                ? prop.childType\n                : typeMaps[prop.childType];\n\n            initializer = `new ${langType}${(prop.type !== \"ref\" && isUpcaseFirst) ? \"<>\" : \"\"}(${ctorArgs})`;\n\n        } else if(prop.type === \"array\") {\n            langType = (isUpcaseFirst)\n                ? `ArraySchema<${prop.childType}>`\n                : `ArraySchema`;\n\n            initializer = `new ArraySchema${(isUpcaseFirst) ? \"<>\" : \"\"}(${ctorArgs})`;\n\n        } else if(prop.type === \"map\") {\n            langType = (isUpcaseFirst)\n                ? `MapSchema<${prop.childType}>`\n                : `MapSchema`;\n\n            initializer = `new MapSchema${(isUpcaseFirst) ? \"<>\" : \"\"}(${ctorArgs})`;\n        }\n\n        if (prop.type !== \"ref\") {\n            typeArgs += (isUpcaseFirst)\n                ? `/ref`\n                : `/${prop.childType}`;\n        }\n\n    } else {\n        langType = typeMaps[prop.type];\n        initializer = typeInitializer[prop.type];\n    }\n\n    property += ` ${langType} ${prop.name}`;\n\n    return `\\t@SchemaField(\"${typeArgs}\")\\t${indent}\n\\t${indent}${property} = ${initializer};`\n}\n","import { Class, Property, File, getCommentHeader, getInheritanceTree, Context } from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\n\nexport const name = \"LUA\";\n\n/**\n    TODO:\n    - Support inheritance\n    - Support importing Schema dependencies\n*/\n\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"string\",\n    \"number\": \"number\",\n    \"boolean\": \"boolean\",\n    \"int8\": \"number\",\n    \"uint8\": \"number\",\n    \"int16\": \"number\",\n    \"uint16\": \"number\",\n    \"int32\": \"number\",\n    \"uint32\": \"number\",\n    \"int64\": \"number\",\n    \"uint64\": \"number\",\n    \"float32\": \"number\",\n    \"float64\": \"number\",\n}\n\nconst COMMON_IMPORTS = `local schema = require 'colyseus.serializer.schema.schema'`;\n\nconst distinct = (value: string, index: number, self: string[]) =>\n    self.indexOf(value) === index;\n\n/**\n * Generate individual files for each class\n */\nexport function generate (context: Context, options: GenerateOptions): File[] {\n    return context.classes.map(klass => ({\n        name: klass.name + \".lua\",\n        content: generateClass(klass, options.namespace, context.classes)\n    }));\n}\n\n/**\n * Generate a single bundled file containing all classes\n */\nexport function renderBundle(context: Context, options: GenerateOptions): File {\n    const fileName = options.namespace ? `${options.namespace}.lua` : \"schema.lua\";\n\n    const classBodies = context.classes.map(klass => generateClassBody(klass));\n    const classNames = context.classes.map(klass => `    ${klass.name} = ${klass.name},`).join(\"\\n\");\n\n    const content = `${getCommentHeader().replace(/\\/\\//mg, \"--\")}\n\n${COMMON_IMPORTS}\n\n${classBodies.join(\"\\n\\n\")}\n\nreturn {\n${classNames}\n}\n`;\n\n    return { name: fileName, content };\n}\n\n/**\n * Generate just the class body (without requires) for bundling\n */\nfunction generateClassBody(klass: Class): string {\n    // Inheritance support\n    const inherits = (klass.extends !== \"Schema\")\n        ? `, ${klass.extends}`\n        : \"\";\n\n    return `---@class ${klass.name}: ${klass.extends}\n${klass.properties.map(prop => `---@field ${prop.name} ${getLUATypeAnnotation(prop)}`).join(\"\\n\")}\nlocal ${klass.name} = schema.define({\n${klass.properties.map(prop => generatePropertyDeclaration(prop)).join(\",\\n\")},\n    [\"_fields_by_index\"] = { ${klass.properties.map(prop => `\"${prop.name}\"`).join(\", \")} },\n}${inherits})`;\n}\n\n/**\n * Generate a complete class file with requires (for individual file mode)\n */\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\n    const allRefs: Property[] = [];\n    klass.properties.forEach(property => {\n        let type = property.type;\n\n        // keep all refs list\n        if ((type === \"ref\" || type === \"array\" || type === \"map\")) {\n            allRefs.push(property);\n        }\n    });\n\n    const localRequires = allRefs.\n        filter(ref => ref.childType && typeMaps[ref.childType] === undefined).\n        map(ref => ref.childType).\n        concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).\n        filter(distinct).\n        map(childType => `local ${childType} = require '${(namespace ? `${namespace}.` : '')}${childType}'`).\n        join(\"\\n\");\n\n    return `${getCommentHeader().replace(/\\/\\//mg, \"--\")}\n\n${COMMON_IMPORTS}\n${localRequires}\n\n${generateClassBody(klass)}\n\nreturn ${klass.name}\n`;\n}\n\nfunction generatePropertyDeclaration(prop: Property) {\n    let typeArgs: string;\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        if (isUpcaseFirst) {\n            typeArgs += `${prop.childType}`;\n\n        } else {\n            typeArgs += `\"${prop.childType}\"`;\n        }\n\n        if(prop.type === \"ref\") {\n            typeArgs = (isUpcaseFirst)\n                ? `${prop.childType}`\n                : `\"${prop.childType}\"`;\n\n        } else {\n            typeArgs = (isUpcaseFirst)\n                ? `{ ${prop.type} = ${prop.childType} }`\n                : `{ ${prop.type} = \"${prop.childType}\" }`;\n        }\n\n    } else {\n        typeArgs = `\"${prop.type}\"`;\n    }\n\n    return `    [\"${prop.name}\"] = ${typeArgs}`;\n}\n\nfunction getLUATypeAnnotation(prop: Property) {\n    if (prop.type === \"ref\") {\n        return prop.childType;\n\n    } else if (prop.type === \"array\") {\n        return \"ArraySchema\";\n\n    } else if (prop.type === \"map\") {\n        return \"MapSchema\";\n\n    } else {\n        return typeMaps[prop.type];\n    }\n}","import { Class, Property, File, getCommentHeader, getInheritanceTree, Context } from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\n\nexport const name = \"C\";\n\n/**\n * Type mappings for C\n */\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"char*\",\n    \"number\": \"double\",\n    \"boolean\": \"bool\",\n    \"int8\": \"int8_t\",\n    \"uint8\": \"uint8_t\",\n    \"int16\": \"int16_t\",\n    \"uint16\": \"uint16_t\",\n    \"int32\": \"int32_t\",\n    \"uint32\": \"uint32_t\",\n    \"int64\": \"int64_t\",\n    \"uint64\": \"uint64_t\",\n    \"float32\": \"float\",\n    \"float64\": \"double\",\n};\n\n/**\n * Colyseus field type enum mappings\n */\nconst fieldTypeMaps: { [key: string]: string } = {\n    \"string\": \"COLYSEUS_FIELD_STRING\",\n    \"number\": \"COLYSEUS_FIELD_NUMBER\",\n    \"boolean\": \"COLYSEUS_FIELD_BOOLEAN\",\n    \"int8\": \"COLYSEUS_FIELD_INT8\",\n    \"uint8\": \"COLYSEUS_FIELD_UINT8\",\n    \"int16\": \"COLYSEUS_FIELD_INT16\",\n    \"uint16\": \"COLYSEUS_FIELD_UINT16\",\n    \"int32\": \"COLYSEUS_FIELD_INT32\",\n    \"uint32\": \"COLYSEUS_FIELD_UINT32\",\n    \"int64\": \"COLYSEUS_FIELD_INT64\",\n    \"uint64\": \"COLYSEUS_FIELD_UINT64\",\n    \"float32\": \"COLYSEUS_FIELD_FLOAT32\",\n    \"float64\": \"COLYSEUS_FIELD_FLOAT64\",\n    \"ref\": \"COLYSEUS_FIELD_REF\",\n    \"array\": \"COLYSEUS_FIELD_ARRAY\",\n    \"map\": \"COLYSEUS_FIELD_MAP\",\n};\n\nconst COMMON_INCLUDES = `#include \"colyseus/schema/types.h\"\n#include \"colyseus/schema/collections.h\"\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdbool.h>`;\n\n/**\n * Native C Code Generator\n */\n\nconst toSnakeCase = (s: string) => {\n    return s.replace(/([A-Z])/g, (match, p1, offset) =>\n        (offset > 0 ? '_' : '') + p1.toLowerCase()\n    );\n};\n\nconst distinct = (value: string, index: number, self: string[]) =>\n    self.indexOf(value) === index;\n\n/**\n * Generate individual files for each class\n */\nexport function generate(context: Context, options: GenerateOptions): File[] {\n    return context.classes.map(klass => ({\n        name: toSnakeCase(klass.name) + \".h\",\n        content: generateClass(klass, options.namespace, context.classes)\n    }));\n}\n\n/**\n * Generate a single bundled header file containing all classes\n */\nexport function renderBundle(context: Context, options: GenerateOptions): File {\n    const fileName = options.namespace ? `${toSnakeCase(options.namespace)}.h` : \"schema.h\";\n    const guardName = `__SCHEMA_CODEGEN_${(options.namespace || \"SCHEMA\").toUpperCase()}_H__`;\n\n    const classBodies = context.classes.map(klass =>\n        generateClassBody(klass, context.classes)\n    ).join(\"\\n\\n\");\n\n    const content = `${getCommentHeader()}\n#ifndef ${guardName}\n#define ${guardName} 1\n\n${COMMON_INCLUDES}\n\n${classBodies}\n\n#endif\n`;\n\n    return { name: fileName, content };\n}\n\n/**\n * Generate just the class body (without guards/includes) for bundling\n */\nfunction generateClassBody(klass: Class, allClasses: Class[]): string {\n    const snakeName = toSnakeCase(klass.name);\n    const typeName = `${snakeName}_t`;\n    const allProperties = getAllProperties(klass, allClasses);\n\n    return `${generateTypedef(klass, typeName, allClasses)}\n\n${generateFieldsArray(klass, typeName, snakeName, allProperties)}\n\n${generateCreateFunction(snakeName, typeName)}\n\n${generateDestroyFunction(klass, snakeName, typeName, allProperties)}\n\n${generateVtable(klass, snakeName, typeName, allProperties)}`;\n}\n\n/**\n * Generate a complete class file with guards/includes (for individual file mode)\n */\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\n    const snakeName = toSnakeCase(klass.name);\n    const typeName = `${snakeName}_t`;\n    const guardName = `__SCHEMA_CODEGEN_${klass.name.toUpperCase()}_H__`;\n\n    const allRefs: Property[] = [];\n\n    klass.properties.forEach(property => {\n        if (property.type === \"ref\" || property.type === \"array\" || property.type === \"map\") {\n            allRefs.push(property);\n        }\n    });\n\n    // Generate includes for referenced schema types\n    const refIncludes = allRefs\n        .filter(ref => ref.childType && typeMaps[ref.childType] === undefined)\n        .map(ref => ref.childType)\n        .concat(getInheritanceTree(klass, allClasses, false).map(k => k.name))\n        .filter(distinct)\n        .map(childType => `#include \"${toSnakeCase(childType)}.h\"`)\n        .join(\"\\n\");\n\n    return `${getCommentHeader()}\n#ifndef ${guardName}\n#define ${guardName} 1\n\n${COMMON_INCLUDES}\n${refIncludes ? `\\n${refIncludes}\\n` : \"\"}\n${generateClassBody(klass, allClasses)}\n\n#endif\n`;\n}\n\nfunction generateTypedef(klass: Class, typeName: string, allClasses: Class[]) {\n    const allProperties = getAllProperties(klass, allClasses);\n\n    const fields = allProperties.map(prop => {\n        const cType = getCType(prop);\n        return `    ${cType} ${prop.name};`;\n    }).join(\"\\n\");\n\n    return `typedef struct {\n    colyseus_schema_t __base;\n${fields}\n} ${typeName};`;\n}\n\nfunction getCType(prop: Property): string {\n    if (prop.type === \"ref\") {\n        return `${toSnakeCase(prop.childType)}_t*`;\n    } else if (prop.type === \"array\") {\n        if (typeMaps[prop.childType]) {\n            return `colyseus_array_schema_t*`;\n        } else {\n            return `colyseus_array_schema_t*`;\n        }\n    } else if (prop.type === \"map\") {\n        if (typeMaps[prop.childType]) {\n            return `colyseus_map_schema_t*`;\n        } else {\n            return `colyseus_map_schema_t*`;\n        }\n    } else {\n        return typeMaps[prop.type] || `${toSnakeCase(prop.type)}_t*`;\n    }\n}\n\nfunction getFieldType(prop: Property): string {\n    return fieldTypeMaps[prop.type] || \"COLYSEUS_FIELD_REF\";\n}\n\nfunction getFieldTypeString(prop: Property): string {\n    // Always return the type itself (ref, array, map, string, number, etc.)\n    return prop.type;\n}\n\nfunction generateFieldsArray(klass: Class, typeName: string, snakeName: string, allProperties: Property[]) {\n    if (allProperties.length === 0) {\n        return `static const colyseus_field_t ${snakeName}_fields[] = {};`;\n    }\n\n    const fields = allProperties.map((prop, i) => {\n        const fieldType = getFieldType(prop);\n        const typeString = getFieldTypeString(prop);\n\n        let vtableRef = \"NULL\";\n\n        if (prop.type === \"ref\" && prop.childType && !typeMaps[prop.childType]) {\n            const childSnake = toSnakeCase(prop.childType);\n            vtableRef = `&${childSnake}_vtable`;\n        } else if ((prop.type === \"array\" || prop.type === \"map\") && prop.childType && !typeMaps[prop.childType]) {\n            const childSnake = toSnakeCase(prop.childType);\n            vtableRef = `&${childSnake}_vtable`;\n        }\n\n        return `    {${prop.index}, \"${prop.name}\", ${fieldType}, \"${typeString}\", offsetof(${typeName}, ${prop.name}), ${vtableRef}, NULL}`;\n    }).join(\",\\n\");\n\n    return `static const colyseus_field_t ${snakeName}_fields[] = {\n${fields}\n};`;\n}\n\nfunction generateCreateFunction(snakeName: string, typeName: string) {\n    return `static ${typeName}* ${snakeName}_create(void) {\n    ${typeName}* instance = calloc(1, sizeof(${typeName}));\n    return instance;\n}`;\n}\n\nfunction generateDestroyFunction(klass: Class, snakeName: string, typeName: string, allProperties: Property[]) {\n    const freeStatements: string[] = [];\n\n    allProperties.forEach(prop => {\n        if (prop.type === \"string\") {\n            freeStatements.push(`    if (instance->${prop.name}) free(instance->${prop.name});`);\n        } else if (prop.type === \"ref\") {\n            if (typeMaps[prop.childType]) {\n                freeStatements.push(`    if (instance->${prop.name}) free(instance->${prop.name});`);\n            } else {\n                const childSnake = toSnakeCase(prop.childType);\n                freeStatements.push(`    if (instance->${prop.name}) ${childSnake}_destroy((colyseus_schema_t*)instance->${prop.name});`);\n            }\n        } else if (prop.type === \"array\" || prop.type === \"map\") {\n            // arrays and maps are scheduled for destruction at the decoder level\n            // freeStatements.push(`    if (instance->${prop.name}) colyseus_${prop.type}_destroy(instance->${prop.name});`);\n        }\n    });\n\n    const freeCode = freeStatements.length > 0 ? freeStatements.join(\"\\n\") + \"\\n\" : \"\";\n\n    return `static void ${snakeName}_destroy(colyseus_schema_t* schema) {\n    ${typeName}* instance = (${typeName}*)schema;\n${freeCode}    free(instance);\n}`;\n}\n\nfunction generateVtable(klass: Class, snakeName: string, typeName: string, allProperties: Property[]) {\n    const fieldCount = allProperties.length;\n\n    return `static const colyseus_schema_vtable_t ${snakeName}_vtable = {\n    \"${klass.name}\",\n    sizeof(${typeName}),\n    (colyseus_schema_t* (*)(void))${snakeName}_create,\n    ${snakeName}_destroy,\n    ${snakeName}_fields,\n    ${fieldCount}\n};`;\n}\n\nfunction getAllProperties(klass: Class, allClasses: Class[]) {\n    let properties: Property[] = [];\n\n    getInheritanceTree(klass, allClasses).reverse().forEach((k) => {\n        properties = properties.concat(k.properties);\n    });\n\n    return properties;\n}\n","import {\n    Class,\n    Property,\n    File,\n    getCommentHeader,\n    getInheritanceTree,\n    Context,\n    Enum,\n} from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\n\nexport const name = \"GDScript\";\n\n/**\n * Type mappings from schema types to GDScript Colyseus.Schema type constants\n */\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"Colyseus.Schema.STRING\",\n    \"number\": \"Colyseus.Schema.NUMBER\",\n    \"boolean\": \"Colyseus.Schema.BOOLEAN\",\n    \"int8\": \"Colyseus.Schema.INT8\",\n    \"uint8\": \"Colyseus.Schema.UINT8\",\n    \"int16\": \"Colyseus.Schema.INT16\",\n    \"uint16\": \"Colyseus.Schema.UINT16\",\n    \"int32\": \"Colyseus.Schema.INT32\",\n    \"uint32\": \"Colyseus.Schema.UINT32\",\n    \"int64\": \"Colyseus.Schema.INT64\",\n    \"uint64\": \"Colyseus.Schema.UINT64\",\n    \"float32\": \"Colyseus.Schema.FLOAT32\",\n    \"float64\": \"Colyseus.Schema.FLOAT64\",\n};\n\nconst containerMaps: { [key: string]: string } = {\n    \"array\": \"Colyseus.Schema.ARRAY\",\n    \"map\": \"Colyseus.Schema.MAP\",\n    \"ref\": \"Colyseus.Schema.REF\",\n};\n\nconst distinct = (value: string, index: number, self: string[]) =>\n    self.indexOf(value) === index;\n\n/**\n * GDScript Code Generator\n */\n\n/**\n * Generate individual files for each class\n */\nexport function generate(context: Context, options: GenerateOptions): File[] {\n    // Enrich typeMaps with enums\n    context.enums.forEach((structure) => {\n        typeMaps[structure.name] = structure.name;\n    });\n\n    return [\n        ...context.classes.map(klass => ({\n            name: `${klass.name}.gd`,\n            content: generateClass(klass, options.namespace, context.classes)\n        })),\n        ...context.enums.filter(structure => structure.name !== 'OPERATION').map((structure) => ({\n            name: `${structure.name}.gd`,\n            content: generateEnum(structure, options.namespace),\n        })),\n    ];\n}\n\n/**\n * Generate a single bundled file containing all classes and enums\n */\nexport function renderBundle(context: Context, options: GenerateOptions): File {\n    const fileName = options.namespace ? `${options.namespace}.gd` : \"schema.gd\";\n\n    // Enrich typeMaps with enums\n    context.enums.forEach((structure) => {\n        typeMaps[structure.name] = structure.name;\n    });\n\n    const enumBodies = context.enums\n        .filter(structure => structure.name !== 'OPERATION')\n        .map(e => generateEnumBody(e));\n\n    const classBodies = context.classes.map(klass => generateClassBody(klass));\n\n    const content = `${getCommentHeader(\"#\")}\n\n${enumBodies.length > 0 ? enumBodies.join(\"\\n\\n\") + \"\\n\\n\" : \"\"}${classBodies.join(\"\\n\\n\")}\n`;\n\n    return { name: fileName, content };\n}\n\n/**\n * Generate just the class body (without preload) for bundling\n */\nfunction generateClassBody(klass: Class): string {\n    // Determine parent class\n    const parentClass = (klass.extends !== \"Schema\")\n        ? klass.extends\n        : \"Colyseus.Schema\";\n\n    const properties = klass.properties;\n\n    const fieldsContent = properties.length > 0\n        ? properties.map(prop => generateFieldDefinition(prop)).join(\",\\n\") + \",\"\n        : \"\";\n\n    // Generate _to_string() method\n    const toStringMethod = generateToStringMethod(klass.name, properties);\n\n    return `class ${klass.name} extends ${parentClass}:\n\tstatic func definition():\n\t\treturn [\n${fieldsContent}\n\t\t]\n\n${toStringMethod}`;\n}\n\n/**\n * Generate _to_string() method for the class\n */\nfunction generateToStringMethod(className: string, properties: Property[]): string {\n    const fieldNames = properties.map(prop => prop.name);\n    const allFields = [\"__ref_id\", ...fieldNames];\n\n    const formatParts = allFields.map(name => `${name}: %s`).join(\", \");\n    const formatString = `${className}(${formatParts})`;\n\n    const selfReferences = allFields.map(name => `self.${name}`).join(\", \");\n\n    return `\\tfunc _to_string() -> String:\n\t\treturn \"${formatString}\" % [${selfReferences}]`;\n}\n\n/**\n * Generate a complete class file with preload (for individual file mode)\n */\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\n    const allRefs: Property[] = [];\n    klass.properties.forEach(property => {\n        let type = property.type;\n\n        // Keep all refs list\n        if ((type === \"ref\" || type === \"array\" || type === \"map\")) {\n            allRefs.push(property);\n        }\n    });\n\n    // Get required preloads for referenced types\n    const preloads = allRefs\n        .filter(ref => ref.childType && typeMaps[ref.childType] === undefined)\n        .map(ref => ref.childType)\n        .concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name))\n        .filter(distinct)\n        .map(childType => `const ${childType} = preload(\"${childType}.gd\")`)\n        .join(\"\\n\");\n\n    return `${getCommentHeader(\"#\")}\n\n${preloads ? preloads + \"\\n\\n\" : \"\"}${generateClassBody(klass)}\n`;\n}\n\n/**\n * Generate a field definition for the definition() array\n */\nfunction generateFieldDefinition(prop: Property): string {\n    let args: string[];\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        // Array or Map container\n        const containerType = containerMaps[prop.type];\n        const childTypeRef = isUpcaseFirst ? prop.childType : typeMaps[prop.childType] || `\"${prop.childType}\"`;\n        args = [`\"${prop.name}\"`, containerType, childTypeRef];\n    } else {\n        // Primitive type\n        const typeRef = typeMaps[prop.type] || `\"${prop.type}\"`;\n        args = [`\"${prop.name}\"`, typeRef];\n    }\n\n    return `\\t\\t\\tColyseus.Schema.Field.new(${args.join(\", \")})`;\n}\n\n/**\n * Generate just the enum body for bundling\n */\nfunction generateEnumBody(_enum: Enum): string {\n    const enumValues = _enum.properties.map((prop, index) => {\n        let value: any;\n\n        if (prop.type) {\n            if (isNaN(Number(prop.type))) {\n                value = `\"${prop.type}\"`;\n            } else {\n                value = Number(prop.type);\n            }\n        } else {\n            value = index;\n        }\n\n        return `\\t\"${prop.name}\": ${value},`;\n    }).join(\"\\n\");\n\n    return `const ${_enum.name} = {\n${enumValues}\n}`;\n}\n\n/**\n * Generate a complete enum file (for individual file mode)\n */\nfunction generateEnum(_enum: Enum, _namespace: string) {\n    return `${getCommentHeader(\"#\")}\n\n${generateEnumBody(_enum)}\n`;\n}\n","import * as fs from \"fs\";\nimport * as path from \"path\";\n\nimport { File } from \"./types.js\";\nimport { parseFiles } from \"./parser.js\";\n\n// Statically import all language generators (for bundling)\nimport * as csharp from \"./languages/csharp.js\";\nimport * as cpp from \"./languages/cpp.js\";\nimport * as haxe from \"./languages/haxe.js\";\nimport * as ts from \"./languages/ts.js\";\nimport * as js from \"./languages/js.js\";\nimport * as java from \"./languages/java.js\";\nimport * as lua from \"./languages/lua.js\";\nimport * as c from \"./languages/c.js\";\nimport * as gdscript from \"./languages/gdscript.js\";\n\nexport const generators: Record<string, any> = { csharp, cpp, haxe, ts, js, java, lua, c, gdscript, };\n\nexport interface GenerateOptions {\n    files: string[],\n    output: string;\n    decorator?: string;\n    namespace?: string;\n    bundle?: boolean;\n}\n\nexport function generate(targetId: string, options: GenerateOptions) {\n    const generator = generators[targetId];\n\n    if (!generator) {\n        throw new Error(\"You must provide a valid generator as argument, such as: --csharp, --haxe or --cpp\");\n    }\n\n    if (!fs.existsSync(options.output)) {\n        console.log(\"Creating\", options.output, \"directory\");\n        fs.mkdirSync(options.output);\n    }\n\n    /**\n     * Default `@type()` decorator name\n     */\n    if (!options.decorator) { options.decorator = \"type\"; }\n\n    // resolve wildcard files\n    options.files = options.files.reduce((acc, cur) => {\n        if (cur.endsWith(\"*\")) {\n            acc.push(...recursiveFiles(cur.slice(0, -1)).filter(filename => /\\.(js|ts|mjs)$/.test(filename)));\n        } else {\n            acc.push(cur)\n        }\n        return acc;\n    }, [])\n\n    const structures = parseFiles(options.files, options.decorator);\n\n    // Post-process classes before generating\n    structures.classes.forEach(klass => klass.postProcessing());\n\n    if (options.bundle && generator.renderBundle) {\n        // Bundle mode: generate all classes/interfaces/enums into a single file\n        const bundled = generator.renderBundle(structures, options);\n        const outputPath = path.resolve(options.output, bundled.name);\n        fs.writeFileSync(outputPath, bundled.content);\n        console.log(\"generated (bundled):\", bundled.name);\n    } else {\n        // Standard mode: write individual files\n        const generatedFiles = generator.generate(structures, options);\n        generatedFiles.forEach((file: File) => {\n            const outputPath = path.resolve(options.output, file.name);\n            fs.writeFileSync(outputPath, file.content);\n            console.log(\"generated:\", file.name);\n        });\n    }\n}\n\nfunction recursiveFiles(dir: string): string[] {\n    const files = fs.readdirSync(dir, { withFileTypes: true });\n    let collect: string[] = [];\n    files.forEach(file => {\n        const filename = path.resolve(dir, file.name);\n        file.isDirectory() ? collect.push(...recursiveFiles(filename)) : collect.push(filename);\n    })\n    return collect;\n}\n","import argv from \"./argv.js\";\nimport { generate, generators } from \"./api.js\";\n\nfunction displayHelp() {\n    console.log(`\\nschema-codegen [path/to/Schema.ts]\n\nUsage (C#/Unity)\n    schema-codegen src/Schema.ts --output client-side/ --csharp --namespace MyGame.Schema\n\nValid options:\n    --output: the output directory for generated client-side schema files\n    --bundle: bundle all generated files into a single file\n\nGenerators:\n${Object.\n    keys(generators).\n    map((targetId) => (\n`    --${targetId}: generate for ${generators[targetId].name}`\n    )).\n    join(\"\\n\")}\n\nOptional:\n    --namespace: generate namespace on output code\n    --decorator: custom name for @type decorator to scan for`);\n    process.exit();\n}\n\nconst args = argv(process.argv.slice(2));\nif (args.help) {\n    displayHelp();\n}\n\nlet targetId: string;\nfor (let target in generators) {\n    if (args[target]) {\n        targetId = target;\n    }\n}\n\nif (!args.output) {\n    console.error(\"You must provide a valid --output directory.\");\n    displayHelp();\n}\n\ntry {\n    args.files = args._;\n    generate(targetId, {\n        files: args._,\n        decorator: args.decorator,\n        output: args.output,\n        namespace: args.namespace,\n        bundle: args.bundle\n    });\n\n} catch (e) {\n    console.error(e.message);\n    console.error(e.stack);\n    displayHelp();\n}\n"],"names":["path","fs","ts","readFileSync","name","typeMaps","COMMON_IMPORTS","capitalize","generate","generateClass","generateInterface","generateEnum","renderBundle","generateClassBody","generateInterfaceBody","generateEnumBody","generateProperty","typeInitializer","COMMON_INCLUDES","distinct","getAllProperties","generatePropertyDeclaration"],"mappings":"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"}